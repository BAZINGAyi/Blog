---
layout: post
tags: [web] # add tag
img: luca-bravo-217276-min.jpg
---

* TOC
{:toc}

# 优化网站前的准备-优化工具

[PageSpeed Insights - 测试网站性能的工具](https://developers.google.com/speed/pagespeed/insights/)
        
[Chrome - 调节工具](https://developers.google.com/web/tools/chrome-devtools/?hl=zh-cn)

[Chrome - 调节 Android 手机](https://developers.google.com/web/tools/chrome-devtools/remote-debugging/?utm_source=dcc&utm_medium=redirect&utm_campaign=2016q3)

---


#  认识网站的渲染过程

要想构建一个拥有快速体验的网络，浏览器需要做大量的工作。但是这些工作对我们开发者来说是被隐藏的。我们所做的就是写一些标记(HTML,JS,CSS)，接着一个漂亮的网页就被构造出来了，但浏览器是怎样利用我们写的标记将页面渲染到屏幕上的呢?接下来我们将着重分析这一过程。并且在掌握浏览器渲染的过程后，我们将优化曾经自己所做的网站。

首先，先介绍一个概念 **关键渲染路径（CRP）**，它表示优先显示和用户操作相关的内容。

通过优化 CRP ，可以显著改善首次加载页面的速度，也更好为构建一个高性能的交互式应用打下基础。


## 渲染过程概述-顺序图解

![web-render-total](/assets/img/15136586994490.jpg)

> 如图中所示，浏览器将最终的页面呈现给我们前，需要做上述的操作，下面我们将每一步骤进行分开的描述和解释。

---

## 构建对象模型

>Document Object Model(DOM)
>Css Object Model(CSSOM)

在浏览器渲染页面前，首先需要构建 DOM 和 CSSDOM 树，所以我们需要尽可能快的将所需要的 CSS 和 HTML 传送给浏览器。

### 将 HTML 转化成 DOM

> Dom (Document Object Model) 是 HTML 和 XML 文档的编程接口。它提供一种方式可以让程序去修改文档的结构、内容和样式。

> 对应 Chrome-DevTools ParseHTML 事件

接下来，我通过一个简单的例子来分析下 DOM 的形成过程。

这个是我们需要[分析的页面](https://googlesamples.github.io/web-fundamentals/fundamentals/performance/critical-rendering-path/basic_dom.html)

我们通过 Chrome-DevTools 捕获页面加载的过程（对应 ParseHTML 过程）：

首先我们可以看到，浏览器根据我们请求的 URL 去服务器获取相应的信息和文件，如下图。而且根据图中请求资源的顺序，可以明显发现，在 html 请求完成后，过了一段时间才会去请求 `style.css` 和 `awesome-photo.jpg` 资源文件，这是怎么回事？之后在 CSSDOM 的构建过程中，我们将会了解到。

![根据请求获取文件](/assets/img/15136627460848.jpg)

我们可以从服务器的回复中看到需要解析的 HTML 标签

![serve-responce](/assets/img/15136628258672.jpg)


浏览器根据获取的 HTML 开始解析。解析的规则是，每当遇到一个标签，浏览器都会按照顺序发出一个 token。如下图所示：

![HTML转换成Token](/assets/img/15120238413376.jpg)

同时浏览器在转换这些 token 的时候，会存在另外一个独立的流程来处理这些 token，将这些 token 转换成 node 对象。并且这些对象按照 token 转换的顺序形成了一定的关系。如下图所示：

![Token被转换成node](/assets/img/15120242445961.jpg)

当所有的 token 都被转换完成后，就形成了文档对象模型（DOM）。

---

### 将 CSS 转换成 CSSOM

> 对应 Chrome-DevTools Recalculate 事件

在浏览器构建页面的 DOM 时，会在文档的 head 部分遇到了一些 `<link>` 标记，该标记用于引用外部的一些 CSS 样式表。由于预见到需要利用该资源来渲染页面，它会立即发出对该资源的请求，并返回对应的 CSS。这也就解释了，在我们之前看到的资源请求为什么会在 HTML 请求的后面。

与处理 HTML 时一样，我们需要将收到的 CSS 规则转换成某种浏览器能够理解和处理的东西。因此，我们会重复 HTML 的构建过程，不过这次请求是为 CSS 而不是 HTML。如下图：

![CSS渲染成CSSDOM](/assets/img/15120260855725.jpg){:width="50%"}

为什么 CSSOM 具有树结构？原因就在计算页面上的任何对象的最后样式时，浏览器都会先从适用于该节点的最通用规则开始（例如，如果该节点是 body 元素的子项，则应用所有 body 样式），然后通过应用更具体的规则（即规则“向下级联”）通过递归方式优化计算的样式。

这里需要注意的是，图中所列出的 CSSOM 并不是完整的，它只是包含我们自己定义的样式。每一个浏览器都会提供一套默认的样式。

要了解 CSSOM 构建所需要的时间，我们可以通过 Chrome - Performance 工具来查看 `Recalculate` 事件

![CSSOM的合成](/assets/img/15136660751180.jpg)

我们可以看到，提供的[测试页面](https://googlesamples.github.io/web-fundamentals/fundamentals/performance/critical-rendering-path/basic_dom.html)花费了大约 0.19s 的时间，并且影响了 9 个元素，但是这 9 个元素从何而来呢，我们只有独立的 DOM 和 CSSOM 啊？看来浏览器还进行了一步隐藏的步骤-合成渲染树。

---

### 将 CSSOM 和 DOM 合并成渲染树

之前我们已经构建了 CSSOM 和 DOM，但是这两个是独立的数据结构，并且影响文档的不同方面。一个影响内容，一个影响样式。这时浏览器就会将其并成一个“渲染树”，之后计算每一个**可视**元素的布局信息（位置，大小、样式），然后作为 `paint process` 进程的输入，再绘制到屏幕上的每个像素上。

![渲染树构建](/assets/img/15120281427001.jpg)

为构建渲染树，浏览器大体上完成了下列工作：

1. 从 DOM 树的根节点开始遍历每个可见节点。

2. 某些节点不可见（例如脚本标记、元标记等），因为它们不会体现在渲染输出中，所以会被忽略。
3. 某些节点通过 CSS 隐藏，因此在渲染树中也会被忽略，例如，上例中的 span 节点，不会出现在渲染树中。因为有一个显式规则在该节点上设置了`display: none`属性。
4. 对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们。
5. 发射可见节点，连同其内容和计算的样式。

---

## 布局

> 对应 Chrome-DevTools Layout 事件

为了弄清每个对象在网页上的确切大小和位置，浏览器从渲染树的根结点开始遍历，计算哪些节点在设备窗口内的确切位置和大小,这时进行的就是 Layout 过程

下面是一个[测试页面](https://googlesamples.github.io/web-fundamentals/fundamentals/performance/critical-rendering-path/basic_dom.html)的渲染过程，我们可以通过如图示中不同的 checkbox 来进行事件的分类和分析


![布局例子](/assets/img/15136713341451.jpg)

---

## 绘制元素

> 对应 Chrome-DevTools Paint 事件

将各个节点绘制到屏幕上，查看绘制的过程和绘制布局的过程一样，这里就不再截图了


