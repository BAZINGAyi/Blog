---
layout: post
tags: [js] # add tag
img: luca-bravo-217276-min.jpg
---

# 优化工具

[测试优化连接](https://developers.google.com/speed/pagespeed/insights/)


[Timeline工具](https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool)

#  网站渲染过程

![web-render-total]({{sita.baseurl}}/assets/img/15120233685588.jpg)

## 将 HTML 转化成 Dom

> Dom (Document Object Model) 是 HTML 和 XML 文档的编程接口。它提供一种方式可以让程序去修改文档的结构、内容和样式

首先浏览器解析 html，每当遇到一个标签，浏览器都会发出一个 token，如下图所示

![HTML转换成Token]({{sita.baseurl}}/assets/img/15120238413376.jpg)

同时浏览器在转换这些 token 的时候，会存在另外一个流程来处理这些 token，将这些 token 转换成 node 对象。并且这些对象按照 token 转换的顺序就形成了一定的关系，如下图所示：

![Token被转换成node]({{sita.baseurl}}/assets/img/15120242445961.jpg)

当所有的 token 都被转换完成后，就形成了文档对象模型

---

## 将 CSS 转换成 CSSOM

在默认的情况下，CSS 被视为阻塞渲染的资源，这就意味着浏览器不会渲染任何已经被处理的内容，直到 CSSOM 被构建，所以尽可能的精简 CSS。

[精简CSS](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css)

在浏览器构建页面的 DOM 时，在文档的 head 部分遇到了一些 link 标记，该标记引用外部的一些 CSS 样式表。由于预见到需要利用该资源来渲染页面，它会立即发出对该资源的请求，并返回对应的 css。

与处理 HTML 时一样，我们需要将收到的 CSS 规则转换成某种浏览器能够理解和处理的东西。因此，我们会重复 HTML 过程，不过这次请求是为 CSS 而不是 HTML，如下图

![CSS渲染成CSSDOM]({{site.baseurl}}/assets/img/15120260855725.jpg)

事实上，这就构成了层叠规则和层叠样式表。可以看见每一个子节点都具有父节点的属性

![Timeline 工具使用](https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool?utm_source=dcc&utm_medium=redirect&utm_campaign=2016q3#saving-and-loading-recordings)

---

## 将 CSSOM 和 DOM 合并成渲染树

有了 CSSOM 和 DOM，浏览器就可以将合并成一个“渲染树”，绘制网页上所有可见的 DOM 内容，以及每个节点的所有 CSSOM 样式信息。如下图所示：

![渲染树构建]({{site.baseurl}}/assets/img/15120281427001.jpg)

为构建渲染树，浏览器大体上完成了下列工作：

1. 从 DOM 树的根节点开始遍历每个可见节点。

2. 某些节点不可见（例如脚本标记、元标记等），因为它们不会体现在渲染输出中，所以会被忽略。
3. 某些节点通过 CSS 隐藏，因此在渲染树中也会被忽略，例如，上例中的 span 节点，不会出现在渲染树中。因为有一个显式规则在该节点上设置了`display: none`属性。
4. 对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们。
发射可见节点，连同其内容和计算的样式。

---

## 布局

为了弄清每个对象在网页上的确切大小和位置，浏览器从渲染数的根结点开始遍历，计算哪些节点在设备窗口内的确切位置和大小

## 绘制元素

将各个节点绘制到屏幕上

