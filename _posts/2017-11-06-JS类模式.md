# 类模式

## 对象装饰器模式 

```js
var carlike = function(obj,loc) {
    obj.loc = loc;
    obj.move = function() {
        obj.loc++;
    };
    return obj;
}
```
<img src="{{site.baseurl}}/assets/img/15100141640873.jpg" alt="pattern" />

装饰器模式中，利用 `carlike`` 生成的每一个对象，都会创建一个属于自己的 `move` 函数

---

## 函数类模式

```js
var Car = function(loc){
    var obj = {loc:loc};
    extend(obj, Car.methods);
    return obj;
};

Car.methods = {
    move:function(){
        move:function(){
            this.loc++;
        }
    }
}
```

<img src="{{site.baseurl}}/assets/img/15100155401507.jpg" alt="pattern1" />

函数类模式也叫函数共享模式，将 move 函数拿出构造函数后，所有的对象都共享一个 `move` 函数，这里使用的 `extend`，在 js 中并没有这个方法，只是表达了 ben 这个对象手动复制了 Car.method 的所有方法

---

## 原型模式

```js
var Car = function(loc) {
    var obj = Object.create(Car.prototype);
    obj.loc = loc;
    return obj;
};

Car.prototype.move = function() {
    this.loc++;
};

console.log(Car.prototype.constructor);
<!--Car 本身-->
console.log(amy.constructor);
<!--Car-->
console.log(amy instance of Car);
<!--amy 的原型链是 Car.prototype 而不是 Car-->
var amy = Car(1);
amy.move();
```

instance of 运算符用于检测 constructor.prototype 是否存在于参数 object 的原型链shang


<img src="{{site.baseurl}}/assets/img/15100158457081.jpg" alt="pattern3" />

使用原型委托的原理，当一个对象进行属性查找时，如果没有找到，可以到另一个对象中去继续查找

## 伪类模式

> 叫做伪类的原因是仿照其他语言中的类系统，增加一些语法上的便利

<img src="{{site.baseurl/assets/img/15099729340112.jpg}}" alt="preudoclassical"/>

我们看到，图中画红圈的部分是每个原型类都需要的部分，所以 javascript 提供关键字 `new` 来代替这两部分，也就是说，只要使用了关键字 `new`,就可以省掉原型类中的画圈的两部分

```js
var Car = function(loc) {
    obj.loc = loc;
};

var amy = new Car(1);
amy.move();
```




