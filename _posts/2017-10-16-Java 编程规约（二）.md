---
layout: post
category: "web"
---

# Java 编程规约（二）
## 集合处理

**关于hashCode 和 equals 的处理**
    1. 只要重写 equasl，就必须重写 hashCode。
    2. 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写这个两个方法
    3. 如果自定义对象作为 Map 的键，那么必须重写 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写这个两个方法
    
> 1.String 重写了两个方法，可以使用 String 对象作为 key 来使用
> 2.object 对象中的 public boolean equals（Object obj），对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true
> 3.当此方法被重写时，通常必须重写 hasCode 方法的目的是由于 hashcode 是用于散列数据的快速读取（HashSet/HashMap／Hashtable等），根据 hashCode 值来进行判断是否是相同的
> 4.如果对一个对象重写了 equals，意思是只要对象的成员变量值相等，则 equals 等于 true，但不重写 hashCode，当我们再 new 一个具有相同值的对象，两者的 hashCode 是不一致的，这会再存储散列集合时（如 Set 类）会存储两个值一样的对象


**ArrayList 的 subList 结果不可强装换成 ArrayList (未深入理解)**

> subList 返回的是 ArrayList 的内部类 SubList，并不似 ArrayList，而是 ArrayList 的一个视图，对于 Sublist 子列表的操作都会反映到原列表上

**在 subList 场景中，高度注意对元集合元素个数的修改，会导致字列表的遍历、删除均产生 ConcurrentModificationException 异常**

**使用集合转数组的方法，必须使用集合的 toArray(T[] array),传入的是类型完全一样的数组，大小为 list.size()**

> 使用 toArray 带参方法，入参分配的数组空间不够大时，toArray 方法内部将重新分配内存空间，并返回新数组地址.如果数组元素大于实际所需，下标为 [list.size()] 的数组元素将被置为 null，其他数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致

```java
List<String> list = new ArrayList<Sting>(2);
list.add("guan");
list.add("bao");
String[] array = new String[list.size];
array = list.toArray(array)
```

> 直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[] 类，若强转其他类型数组将出现 ClassCastException 错误

**使用工具类 Arrays.asList() 把数组转成集合时，不能使用其修改集合的相关方法**

> 它的 add/remove/clear 方法会抛出 UnsupportedOperationException 
> asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。 Array.asList() 体现的是适配器模式，只是转换接口，后台的数据仍是数组。

```Java
String[] str = new String["you", "wu"];
List list = Arrays.asList(str);

// list.add("z"); 错误
// str[0] = "gu"; 那么 list.get(0) 的值也会被修改
```

**泛型通配符 的用法 (理解不深)**

1. <? extends T> 来接受返回的数据，此方法的泛型集合不能使用 add 方法
2. <? super T> 不能使用 get 方法，做为接口调用赋值时容易出错

> 根据 PECS(Producer Extends Consumer Super) 原则：频繁向外读取内容的，适用<? extends T>. 经常往里插入得，适用于 <? super T>

**不要在 foreach 循环里进行元素的 remove/add 操作**

> remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁

```Java
Iterator <String> iterator = list.iterator();
while (iterator.hasNext());
    if (删除的条件) {
	    iterator.remove();
    }
}
```

```java
// 反例
List<String> list = new ArrayList<string>();
list.add("1");
list.add("2");
for (String item: list) {
	if ("1".equals(item)){
		list.remove(item);
	}
}
```

**在 JDK7 版本及以上, Comparator 要满足如下三个条件，不然 Array.sort，Collections.sort 会报 IllegalArgumentException 异常**

1. x,y 的比较结果和 y,x 的比较结果相反
2. x>y, y>z, 则 x>z
3. x=y,则 x,z 的比较结果和 y,z 比较结果相同

```java
// 反例 没有处理相等的情况
new Comparator<Student>() {
	@Override
	public int compare(Student o1, Student o2) {
		return o1.getId() > o2.getId() ? 1:-1;
	}
}
```

**集合初始化时，指定集合初始化大小**

> initalCapacity = (需要存储的元素个数 / 负载因子) + 1。 负载因子默认为 0.75，如果暂时无法确定初始值大小，请设置 16 。
> HashMap 使用 HashMap( int initialCapacty) 初始化
> HashMap 需要放置 1024 个元素由于没有设置容量初始化大小，随着元素的不断增加，容量被迫扩大 7 次，resize 需要重建 hash 表，严重影响性能

**10. 使用 entrySet 遍历 Map 类集合 KV,而不是 keySet 方式进行遍历**

> keySet 是遍历了 2 次，一次转为 Iterator 对象，另一次从 hashMap 中取出 key 所对应的 value。 而 entrySet 只是遍历了一次就把 key 和 Vaule 都放到了 entry 中，效率更高。
> 在 JDK8 中，使用 Map.foreach 方法
> vaules() 返回的是 V 值集合，list 对象。 keySet() 返回的是 Set 集合对象，entrySet() 返回的是 K-V 值组合集合。

**11. Map 类集合 K/V 能不能存储 null 值得情况**

| 集合类 | key | Vaule | Super | 说明 |
| ---- | ----- | ----| ----| ----- |
| Hashtable | 不允许为 null | 不允许为 null | Dictionary | 线程安全 |
| ConcurrentHashMap | 不允许为 null | 不允许为 null | AbstractMap | 锁分段技术|
| TreeMap | 不允许为 null | 允许为 null | AbstractMap | 线程不安全|
| HashMap | 允许为 null | 允许为 null | AbstractMap | 线程不安全| 


**12. 合理利用好集合的有序性(sort)和稳定性(order),避免集合的无序性和不稳定性带来的负面的影响**

> ArrayLisr 是 order/unsort; HashMap 是 unorder/unsort; TreeSet 是 order/sort。

**13. 利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的 contains 方法进行遍历、对比、去重操作。



## 并发处理

**获取单例对象需要保证线程的安全，其中的方法也要保证线程安全**

> 资源驱动类，工具类，单例工厂类都需要注意

**指定有意义的线程名称**
**线程资源必须通过线程池提供，不允许在应用中自行显式创建线程**

> 使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者"过度切换的问题"

**线程池不允许使用 Executors 创建，通过 ThreadPoolExecutor 的方式创建，有利于更加明确线程池的运行规则，避免资源耗尽的风险**

> 使用 Executors 返回的线程池对象的弊端如下：
> 1. FixedThreadPool 和 SingleThreadPool:允许请求的队列长度为 Integer.MAX_VALUE,可能会堆积大量的请求，从而导致 OOM.
> 2. CachedTheadPool 和 ScheduledThreadPool:允许的创建的线程数量为 Integer.MAX_VALUE, 从而导致 OOM.

**SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果为 static 必须加锁，或者使用 DateUtils 工具类**

```Java
private staic final ThreadLocal<DateFormat> df = new ThreadLocal<DateFormat>() {
	@Override
	protected DateFormat initialVaule() {
		return new SimpleDateFormat("yyyy-MM-dd");
	}
}
```

> JDK8 的应用，用 Instant 代替 Date，LocalDateTime 代替 Calendar，DateTimeFormatter 代替 SimpleDateFormat

**高并发时，同步调用应该去考量锁的性能损耗。能用无锁的数据结构，就不要用锁，能用锁区块，就不要锁整个方法体，能用对象锁，就不用类锁。**

> 尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用 RPC 方法。

**对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能造成死锁**

> 线程需要对表 A,B,C 依次全部加锁后才可以进行更新操作，线程二的加锁顺序也必须是 A、B、C, 否则可能出现死锁







