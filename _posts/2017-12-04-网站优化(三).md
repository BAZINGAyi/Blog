---
layout: post
tags: [js] # add tag
img: js-head.png
---

> 这是一篇拓展文章讲解了浏览器如何提高加载 WEB 页面的速率

# 浏览中的 Pre-loader

## 浏览器如何加载 Web pages

一个 Web pages 的显示需要下载完整的依赖 - 一个页面直到相关的 CSS 文件后下载后，才能开始下载。当 HTML 解析器遇到脚本时，会暂时停止解析，直到脚本被执行完成（当然如果这个脚本文件是外部引入的文件同样也需要下载）

下面我们来思考一下浏览器加载页面的几种情况：

* 首先当 HTML 被下载后，浏览器开始解析。解析的过程中会找到需要引入的外部 CSS 文件，然后会对这个 CSS 进行下载

* 在外部的 CSS 文件在下载时，HTML 会被继续解析，但在这时如果解析器遇到外部引用的 `<script>` 标签（除非带有 `defer` 和 `async` 属性），解析必须停止直到脚本文件被下载并执行完成才能继续

* 一旦外部脚本文件被下载和执行完成，浏览器会继续解析 HMTL，当浏览器发现非阻塞资源（如图片），会继续解析。但是如果遇到脚本文件就必须停下来，等待脚本文件被检索后执行完成。

虽然浏览器有能力同时发起多个请求，当在执行脚本文件时，却绝对不可以下载任何资源，下面给出一个 IE7 下载的示意图

![browsers-downlad-IE7]({{site.baseurl}}/assets/img/15123672772855.jpg)


我们可以从图中很明显的看出 Js 的执行是同步的，而图片的下载是并发的

---

## Pre-loader 是怎样改善网络的

IE，WebKit 和 Mozilla 全都实现了 pre-loader 在 2008前，克服较低的网络利用率当等待下载脚本文件和其执行时

当浏览器因为脚本被阻塞时，一个轻量级的解析器会扫描剩下的标签寻找其他页需要被得到的资源（如样式表，脚本，图片等）

然后 pre-loader 开始在后台下载这些需要被得到的资源，当 HTML 解析器扫描到这些资源时，他们已经被下载好了。以这样的方式减少之后页面的阻塞

这里我们重复之前在 IE7 的下载图，会发现后很大的改善

![browsers-downlad-IE8]({{site.baseurl}}/assets/img/15123689112561.jpg)

---

## Pre-Loader 的问题

由于 Pre-Loader 的提取方式是从标签上读取，这就会导致无法读取由 js 写入内嵌的资源，这部分资源将会被延迟发现并加载它们

```js
<html>
<head>
  <script>
      var file = window.innerWidth < 1000 ? "mobile.css" : "desktop.css";
      document.write('<link rel="stylesheet" type="text/css" href="css/' + file + '"/>');
  </script>
</head>
<body>
<img src="img/gallery-img1.jpg" />
<img src="img/gallery-img2.jpg" />
<img src="img/gallery-img3.jpg" />
<img src="img/gallery-img4.jpg" />
<img src="img/gallery-img5.jpg" />
<img src="img/gallery-img6.jpg" />
</body>
</html>
```

这里我们可以看出 css 的写入方式是内嵌的，所以刚开始下载时未被发现。下面给出在 IE9 加载过程：

![browsers-downlad-IE9]({{site.baseurl}}/assets/img/15123695926479.jpg)

---

# 结合 Preload 分析

没有 Preload 的浏览器执行：

![browsers-no-preload]({{site.baseurl}}/assets/img/15123704052674.jpg)


首先 HTML 解析器会解析 DOM，然后遭遇 css 标签，接着发起请求获得 css 文件，这时我们可以接着构建 dom，但不巧的是我们有遇到了 `app.js` 文件，这时 HTML 解析器被阻塞，等待 `app.js` 脚本文件。当我们得到 CSS 文件，并且构建成 CSSDOM，这是 `app.js` 开始运行，执行完成后继续加载 DOM。接着遇到 `timing.js`，然后停止 HTML 的解析，等待 `timing.js` 下载和执行完成。

有 Preload 的浏览器执行：

当一次遇到`app.js` 文件被阻塞时，通过 pre-loader 的加载方式会继续发现 `timing.js`，然后一起下载

![browsers-preload]({{site.baseurl}}/assets/img/15123705955504.jpg)


# 参考文献

[Pre-loader](https://andydavies.me/blog/2013/10/22/how-the-browser-pre-loader-makes-pages-load-faster/)

