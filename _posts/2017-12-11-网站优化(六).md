---
layout: post
tags: [js] # add tag
img: luca-bravo-217276-min.jpg
---


* TOC
{:toc}

# Pipeline - Recalculate Style 的优化

> 渲染管道的第二步骤
> 减少选择器的匹配 意味着使用更少的标签或者类名来选择元素
> 减少影响的元素 意味着更少的改变渲染树

在之前，我们已经优化了 Pipeline 管道中的第一部分（Javascript），并且已经了解到，PipeLine 的执行是顺序的。现在，我们就来分析下，看看如何优化 `style` 部分。

在这一过程中，主要进行的是样式计算。此过程是根据匹配选择器（例如 `.headline` 或 `.nav > .nav__item`）计算出哪些元素应用哪些 CSS 规则的过程。从中知道规则之后，将应用规则并计算每个元素的最终样式。

来考虑一下这样一个例子，在下图中类 `box` 和 `b-3` 哪一个的风格会尽快被应用？

![Recalculate-Style 的优化](/assets/img/15132211643133.jpg)

答案当然是 `box` 在匹配时仅仅是个类名,`.b-3 :nth-child`在匹配时需要计算自己是不是第三个子元素，这就导致了来回在渲染树上移动。

> 关于 `b-3` 的定位过程，选择器在匹配时，会先找到 `b-3` 这个类所在的标签，然后进行回溯，判断自己是不是当第三个孩子

可以看出在关于 `style` 方面的优化，元素的匹配时间将会是我们优化的重点。

---

## 什么是 BEM ？


[BEM and SMACSS](https://www.sitepoint.com/bem-smacss-advice-from-developers/)

[快速开始 BEM](https://en.bem.info/methodology/quick-start/)

CSS 的使用方法可能让人非常疑惑和难以抉择。让我们来思考下最长用的两个选项：BEM 和 SMACSS

BEM 代表了 Block Element Modifier，起源于 Yandex. 他提供了更严格的方法去安排你的 CSS 类，在一个独立的模型中。这里有一些观点发生了变动，但是最常见的看起来是这样的

```
.block {}
.block__element {}
.block--modifier {}
.block__element--modifier {}
```
**Block** 代表在你的网站的一个对象，例如：

* a person
* a login form
* a menu
* a search form

**Element** 是一个 block  内的组件，去执行特定的功能。它只在这个 block 的情况时，才有意义。例如：

* a hand
* a login button
* a menu item
* a search input field

**Modifier** 是如何去表示这个 block 的变化

* a tall／short person 
* a condensed login form
* a menu modified to look differently for a footer or sitemap
* a search input field
* a search input filed with a particular button style

下面给出一个菜单的例子，类的命名可以是这样：

```
.menu {}
.menu__item {}
.menu__item--featured {}
.menu--footer {}
```

还有一些其他的构建原则和工具在 [bem.info](https://www.bem.info/) 上，然而当开发者讨论 BEM 时，他们总是将主要的焦点发在命名的转换上，并且大多数的讨论确实如此。

--- 

## BEM 组件的介绍及使用

### Block

一个功能独立的可被重用的页面组件，在 HTML 中，Block 通过 Class 属性表示。

Block 的命名描绘了它的目的（它是什么，菜单或者按钮），而不是描绘状态（它看起来是什么样的，红的或者白的）

```html
<!-- Correct. The `error` block is semantically meaningful -->
<div class="error"></div>

<!-- Incorrect. It describes the appearance -->
<div class="red-text"></div>
```

* block 应该影响它自己的区域，也就是说你不应该为这个 block 设置外部的边距或位置
* 在使用 BEM 时，也不应该使用 CSS tag 或者 ID 选择器

为了保证 block 的重用或者从直接从一处拿到另一处使用，需要保证必要的独立


#### Block 的使用指南

##### 嵌套

* Blocks 互相可以任意的嵌套
* 可以设置任意的嵌套数量

```html
<!-- `header` block -->
<header class="header">
    <!-- Nested `logo` block -->
    <div class="logo"></div>

    <!-- Nested `search-form` block -->
    <form class="search-form"></form>
</header>
```
---

### Element

块的组成部分，不能从中分离

特性：

* element 的名字描述了它的目的（它是什么，列表的条目或者文本），而不是状态（它是什么类型，看起来是什么样？红的，大的等）
* element 的结构的完成名字是 `block-name__element-name`. element 的名字通过一个 `__` 和 block 分离

```html
<!-- `search-form` block -->
<form class="search-form">
    <!-- `input` element in the `search-form` block -->
    <input class="search-form__input">

    <!-- `button` element in the `search-form` block -->
    <button class="search-form__button">Search</button>
</form>
```
#### elements 的使用指南

##### 嵌套

* element 在内部互相可以被嵌套
* 可以设置任意数量的嵌套等级
* 一个 element 总是 block 的一部分，不属于其他 element。这就意味着 element 不能定义层次结构，如 `block__elem1__elem2` 

```html
<!--
    Correct. The structure of the full element name follows the pattern:
    `block-name__element-name`
-->
<form class="search-form">
    <div class="search-form__content">
        <input class="search-form__input">

        <button class="search-form__button">Search</button>
    </div>
</form>

<!--
    Incorrect. The structure of the full element name doesn't follow the pattern:
    `block-name__element-name`
-->
<form class="search-form">
    <div class="search-form__content">
        <!-- Recommended: `search-form__input` or `search-form__content-input` -->
        <input class="search-form__content__input">

        <!-- Recommended: `search-form__button` or `search-form__content-button` -->
        <button class="search-form__content__button">Search</button>
    </div>
</form>
```

**块的名字定义了命名空间，这就保证了元素是依赖这个 block 的**

一个 block 中可以嵌套这样的结构：

```
<div class="block">
    <div class="block__elem1">
        <div class="block__elem2">
            <div class="block__elem3"></div>
        </div>
    </div>
</div>
```

然而，在 BEM 方法论里，上面这个块的结构代表了一个平级的元素列表

```
.block {}
.block__elem1 {}
.block__elem2 {}
.block__elem3 {}
```

这就允许你不用更改每一个分开元素的代码，就可以改变块的 DOM 结构

```html
<div class="block">
    <div class="block__elem1">
        <div class="block__elem2"></div>
    </div>

    <div class="block__elem3"></div>
</div>
```

块的结构改变，但是 element 和它的名字却保持相同


#### 成员关系

一个 element 总是 block 的一部分，你不能将它从块中分离

```html
<!-- Correct. Elements are located inside the `search-form` block -->
<!-- `search-form` block -->
<form class="search-form">
    <!-- `input` element in the `search-form` block -->
    <input class="search-form__input">

    <!-- `button` element in the `search-form` block -->
    <button class="search-form__button">Search</button>
</form>

<!--
    Incorrect. Elements are located outside of the context of
    the `search-form` block
-->
<!-- `search-form` block -->
<form class="search-form">
</form>

<!-- `input` element in the `search-form` block -->
<input class="search-form__input">

<!-- `button` element in the `search-form` block-->
<button class="search-form__button">Search</button>
```

#### 可选择性

一个 element 只是一个 block 的选择的组建，不是所有的块都需要 element

```
<!-- `search-form` block -->
<div class="search-form">
    <!-- `input` block -->
    <input class="input">

    <!-- `button` block -->
    <button class="button">Search</button>
</div>
```

### 怎样选择创建 block 还是 element？

**创建 block**
如果一个代码块可能被重用并且它不依赖其他页面的组件的实现

**创建 element**

如果一个代码块在没有父母实体的情况下，不能单独的使用

element 为了简化卡法，必须被拆分成小的部分-子 element，在 BEM 的策略下，你不能在 element 内再创建一个 element. 在这种情况下，你需要创建一个服务 block 来代替创建 element.

### Modifier

定义了一个 block 或者 element 的外观，状态，行为等

特性：

* modifier 名字描述它的外观（如大小的尺寸，那一个样式，如 `size_s` 或者 ` theme_islands`）,状态（如和其他的不同之处，如 `disabled`,`focused`,etc) 和它的行为（怎样响应用户，如 `directions_left-top`).
* modifier 名字是从通过 `_` 在 block 或者 element 的名字后分开


### modifier 的类型

#### Boolean

* 仅在 modifier 的存在或不存在时是很重要的时候使用，并且它的值不相关的。例如 `disabled`，如果 Boolean modifier 存在时，它的值猜测为 `ture`
* modifier 的名字应该跟随以下模式：
    * `block-name_modifier-name`
    * `block-name__element-name_modifier-name`

```
<!-- The `search-form` block has the `focused` Boolean modifier -->
<form class="search-form search-form_focused">
    <input class="search-form__input">

    <!-- The `button` element has the `disabled` Boolean modifier -->
    <button class="search-form__button search-form__button_disabled">Search</button>
</form>
```

#### Key-value

* 在 modifier 的值时重要的时候，使用。如一个菜单有 `island` 的主题样式时，设置：`menu_theme_islands`
* modifier 的名字应该跟随以下模式：
    * `block-name_modifier-name_modifier-value`
    * `block-name__element-name_modifier-name_modifier-value`

```html
<!-- The `search-form` block has the `theme` modifier with the value `islands` -->
<form class="search-form search-form_theme_islands">
    <input class="search-form__input">

    <!-- The `button` element has the `size` modifier with the value `m` -->
    <button class="search-form__button search-form__button_size_m">Search</button>
</form>

<!-- You can't use two identical modifiers with different values simultaneously -->
<form class="search-form
             search-form_theme_islands
             search-form_theme_lite">

    <input class="search-form__input">

    <button class="search-form__button
                   search-form__button_size_s
                   search-form__button_size_m">
        Search
    </button>
</form>
```

### modifiers 的使用规则

#### modifier 不能单独使用

根据 BEM 规则，modifier 不能在 block 或 element 不存在时使用。modifier 改变实体的外观，状态，行为，不能代替实体。

### Mix

将使用的不同 BEM 实体应用在同一个 DOM 节点上

Mixes 允许这样做：

* 在没有重复的代码上联合行为和风格不同的实体
* 在已经存在的组件上创建语义化的新 UI 组件

```
<!-- `header` block -->
<div class="header">
    <!--
        The `search-form` block is mixed with the `search-form` element
        from the `header` block
    -->
    <div class="search-form header__search-form"></div>
</div>
```

在这个例子中，我们将 `search-form` block 和 在 header block 中的` header__search-form` element 的行为和风格联合在一起。这种方式允许我们在 `header__search-form` 去设置外部的几何和位置结构,而且 `search-form` block 本身还是保持通用的。这样做后，我们可以将 `search-form` block 应用在其他任何环境，因为它本身没有设置任何填充。这就是为什么我们称之为独立的。

### 文件结构

[BEM](https://en.bem.info/methodology/filestructure/#file-structure-organization)

组件方法应用了 BEM 策略，也应该文件的结构上应用。将 B,E,M 的实现应用在独立的文件上，也就意味着我们可以独立的连接它们。

特性：

* 一个单独的块用于一个单独的目录
* 块的名字和文件夹有相同的名字。距离来说 `header` 应在 `header/` 的文件夹下。
* 一个块的实现应该分离在不同的策略文件中，如 `header.css` 和 `header.js`.
* 块的目录时 E和M 目录的根目录。
* E 文件夹命名以 `__` 开始，如 `header/__logo/` 和 `menu/__item/`.
* M 文件夹命名以 `_` 开始，如 `header/_fixed` 和 `menu/_theme_islands/`
* E 和 M 的实现被分成独立的技术文件。 例如，`header__input.js`和`header_theme_islands.css`。

```
search-form/                           # Directory of the search-form

    __input/                           # Subdirectory of the search-form__input
        search-form__input.css         # CSS implementation of the
                                       # search-form__input element
        search-form__input.js          # JavaScript implementation of the
                                       # search-form__input element

    __button/                          # Subdirectory of the search-form__button
                                       # element
        search-form__button.css
        search-form__button.js

    _theme/                            # Subdirectory of the search-form_theme
                                       # modifier
        search-form_theme_islands.css  # CSS implementation of the search-form block
                                       # that has the theme modifier with the value
                                       # islands
        search-form_theme_lite.css     # CSS implementation of the search-form block
                                       # that has the theme modifier with the value
                                       # lite

    search-form.css                    # CSS implementation of the search-form block
    search-form.js                     # JavaScript implementation of the
                                       # search-form block
```

如果遵循这样的文件结构将非常容易的支持代码重用，这样的文件结构假设是代码将会组装在共享工程文件的产品中

你不用必须去跟随这样推荐的文件结构，你可以使用任何的文件结构，只要文件结构遵循 BEM 原则，例如：

* [Flat](https://en.bem.info/methodology/filestructure/#flat)
* [Flex](https://en.bem.info/methodology/filestructure/#flex)




