---
layout: post
tags: [web] # add tag
img: luca-bravo-217276-min.jpg
---


* TOC
{:toc}

# Pipeline - Recalculate Style 的优化

> 渲染管道的第二步骤
> 减少选择器的匹配 意味着使用更少的标签或者类名来选择元素
> 减少影响的元素 意味着更少的改变渲染树

在之前，我们已经优化了 Pipeline 管道中的第一部分（Javascript），并且已经了解到，PipeLine 的执行是顺序的。现在，我们就来分析下，如何优化 `style` 部分。

在这一过程中，主要进行的是样式计算。此过程是根据匹配选择器（例如 `.headline` 或 `.nav > .nav__item`）计算出哪些元素应用哪些 CSS 规则的过程。从中知道规则之后，将应用规则并计算每个元素的最终样式。

来考虑一下这样一个例子，在下图中类 `box` 和 `b-3` 哪一个的风格会尽快被应用？

![Recalculate-Style 的优化](/assets/img/15132211643133.jpg)

答案当然是 `box` 在匹配时仅仅是个类名,`.b-3 :nth-child`在匹配时需要计算自己是不是第三个子元素，这就导致了来回在渲染树上移动。

> 关于 `b-3` 的定位过程，选择器在匹配时，会先找到 `b-3` 这个类所在的标签，然后进行回溯，判断自己是不是当第三个孩子

可以看出在关于 `style` 方面的优化，元素的匹配时间将会是我们优化的重点。

关于 CSS 元素匹配方面的优化，可以看下[BEM](https://bazingayi.github.io/BEM介绍/)的内容。

> BEM 官网的 CSS 就应用了 BEM 规则，开始的时候我们可以通过观察官网的布局来进行学习

---

# Pipeline - Layout 的优化

## Layout Thrashing

维持 Pipeline 的顺序十分重要，保证了每一帧的绘制。但有时可能会产生这样的问题：

使用 JS 去获取元素的长宽等信息，接着又去改变这个元素的样式信息。正常来想，这样操作是没有什么问题，但是这样操作却间接的改变了 Pipeline 的绘制顺序，造成了 Layout Thrashing 问题。单一的操作不会产生什么影响，但是如果涉及对大量的元素操作，这就会引发相当严重的问题，造成网站的加载缓慢。

可以看下下面的代码：

```js
var sizer = document.querySelector('.sizer');
var ps = document.querySelectorAll('.lipsum-blocks p');
var i = ps.length;
while (i--) {
        ps[i].style.width = sizer.offsetWidth + 'px';
}
```

我们发现先是通过 `sizer.offsetWidth` 获取绿色长条的宽度，而该操作是需要进行 Layout 绘制的，也就是说将 Layout 放到了 JS 部分去执行，这样做本身不引发太大问题，可是接下来的操作是改变每个段落的宽度大小，该操作则会 引发 style 的改变，接着又进行一次 layout 的计算。问题更大的是，还在一个循环中进行，这就直接导致了卡顿，下面的绘制图也证明了我们的看法。

![Layout Thrashing](/assets/img/15141681955720.jpg)

通过 chrome 工具我们可以看出，有很多的警告产生，提示我们发生了 Layout Thrashing 的问题。这时我们可以凭借经验或者[csstriggers 触发器](https://csstriggers.com/)和[Css 触发](http://gent.ilcore.com/2011/03/how-not-to-trigger-layout-in-webkit.html)等网站来确定当前的 JS 操作会引发 Pipeline 的那些步骤。进而优化我们的写法。

这是对上面问题给出的优化代码： 

```js
var sizer = document.querySelector('.sizer');
var ps = document.querySelectorAll('.lipsum-blocks p');
var i = ps.length;
var width = sizer.offsetWidth;
while (i--) {
        ps[i].style.width = width + 'px';
}
```



