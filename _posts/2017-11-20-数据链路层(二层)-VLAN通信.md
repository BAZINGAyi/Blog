---
layout: post
tags: [network] # add tag
img: internet.jpg
---


----

# 配置 VLAN

Vlan 翻译成中文，是"虚拟局域网"。 LAN 可以是由少数几家用计算机构成的网络，也可以是数以百计的计算机构成的企业网络。VLAN 所指的 LAN 特指使用路由器分割的网络，也就是广播域。

二层交换机只能构建单一的广播域，不过使用 VLAN 功能后，能够将网络分割成多个广播域。

VLAN TAG 包的 VLAN ID 号，有效范围是 1-4094，0 和 4095 都为协议保留值，VLAN ID 0 表示不属于任何VLAN，但携带 802.1Q 的优先级标签，所以一般被称为Priority-only frame，其一般作为系统使用，用户不可使用和删除。1 为系统默认 VLAN，即 Native VLAN，2-1001 是普通的 vlan，1006-1024 保留仅系统使用，用户不能查看和使用，1002-1005是支持 fddi 和令牌环的 vlan，1025-4095 是扩展的 vlan。

中继链路：是只承载标记数据(即具有 VLANID 标签的数据包)的干线链路
---

## 交换机端口工作模式简介

Access:
Access 类型的端口只能属于一个 VLAN，一般用于连接中断设备

Trunk:
Trunk 类型的端口可以允许多个 VLAN通过，可以接收和发送多个 VLAN 的报文，一般用于交换机之间的连接端口

Hybird:
Hybird 类型的端口允许多个 VLAN 通过，可以接收和发送多个 VLAN 的报文，可用在交换机或终端设备之间

> Hybird 类型和 Trunk 端口在接收数据时，处理方法一致，不同在于发送数据时，Hybird 端口可以允许多个 VLAN 报文发送时不打标签，而 Trunk 端口只允许缺省 VLAN(本征 VLAN) 时不打标签

---

## 交换机接口出入数据的处理过程

### 端口接收数据时的处理：

Access: 收到一个报文，判断是否带有 VLAN 信息，如果没有打上端口的 PVID，并进行交换转发，如果有则丢弃(原因是一般 Access 接收端口和终端设备直连，这就导致发送的端口数据一般不含有 VLAN 信息)

Trunk: 收到一个报文，判断是否有 VLAN 信息，如果没有则打上端口的 PVID，并进行交换转发，如果判断有 VLAN 信息，并且该 Trunk 端口允许该 VLAN 的数据进入，则将报文带有原有 VLAN 标记进行转发，否则丢弃

Hybird: 收到一个报文,判断是否有VLAN信息,如果没有则打上端口的PVID，并进行交换转发，如果没有则判断该hybrid端口是否允许该VLAN的数据进入：如果可以则转发，否则丢弃。

### 端口发送数据的处理：

Access: 将报文的 VLAN 信息移除，之间转发

Trunk: 比较端口的 PVID 和将要发送报文的 VLAN 信息，如果两者相等则剥离 VLAN 信息，再发送，否则报文将携带原有的 VLAN 标记进行转发。(也就是说发送的是本征 VLAN 时，trunk 端口会去除 VLAN 信息)

> 注意每一个端口都可以设置本征 VLAN

Hybird: 有待补充，理解不深

---

## 通信过程

![VLAN]({{site.baseurl}}/assets/img/VLAN.png)

假设所有交换机都刚开机，PC 发出一个数据包经过交换机 SW1，交换机会按照 端口的 PVID 打上 10 的 TAG 标记，然后交换机会把这个数据帧转发给 VID = 10 的所有端口（除了进口），如下：

![tag]({{site.baseurl}}/assets/img/tag.png)

由于 SW1 的 Trunk 口拥有 VID = 10，进而接受 Tag ，并进行转发，数据帧到达 SW3 后，e0/2 和 e 0/3 均为 trunk 口，发现可接受 TAG 为 10 的 tagged 数据帧，直接进行转发，如下

![trunk]({{site.baseurl}}/assets/img/trunk.png)

SW2 的 trunk 口，e 0/3 同样也能接受 VID = 10 的数据。并且在 e 0/0 的 access 口进行 untag。而 e 0/1 的 access 只能接受 vid = 20 的数据，所以不能进行转发。如下：

![untag]({{site.baseurl}}/assets/img/untag.png)

这样 PC3 就正常接收到 PC1 的数据了

---

## 配置过程

```
PC1、PC2、PC3、PC4 配置 IP

Sw1：
sw1(cinfig)# vlan 10
sw1(cinfig)# vlan 20
sw1(config)# int e0/0sw1(config-if)# switchport mode access sw1(config-if)# switchport access vlan 10
sw1(config-if)# exit
sw1(config-if)# switchport mode access sw1(config-if)# switchport access vlan 10
sw1(config-if)# exit
sw1(config)#int e0/2sw1(config-if)# switchport trunk encapsulation dot1q sw1(config-if)# switchport mode trunk

sw1# show vlan brief 
sw1# show interfaces trunk

Sw3:
sw3(config)# vlan 10
sw3(config)# vlan 20
sw3(config)# int range e0/2-3sw3(config-if-range)# switchport trunk encapsulation dot1qsw3(config-if-range)# switchport mode trunk
```
---

## 拓展

问题：有这么一个要求，在 SW1 和 SW3 之间传递的数据不带 VLAN10 的标签

解决：由于还需要保证双方的通信，所以 SW1 与 SW3 之间的 TRUNK 是不能改变的，但是在 TRUNK 模式下，发送的 TRUNK 端口可以将本征 VLAN 的标签去除，我们可以利用这个特点

**改变本征 VLAN 时，在同一条链路时要同时改**

```
//修改 SW1 e 0/2 端口
sw1(config-if)# switchport trunk native 10

//修改 SW3 e 0/2 端口
sw3(config-if)# switchport trunk native 10
```
---

### 拓展通信过程

PC1 发送数据包进入，SW1 e0/0 的 access 端口，打上 vlanId = 10 的标签，SW1 匹配后，转发到相应接口 e0/2，由于该接口的本征 VLAN 为10，又是发送的 TRUNK 端口，进而将 VlanID = 10 的标签去除。如图：

![modift-nativevlan1]({{site.baseurl}}/assets/img/modift-nativevlan1.png)

可以看到 SW1 与 SW3 链路中并没有添加的 VLANID 标签

在 SW3 e0/2 端口，收到没有 VLAN Tag 的数据，因此进行加 TAG 操作，此时数据包上带有 VLANId = 10 的标签，进行匹配后，e 0/3 对该数据进行转发。如图：

![modift-nativevlan2]({{site.baseurl}}/assets/img/modift-nativevlan2.png)

可以看到，在 SW2 与 SW3 的链路上带有 VLANId = 10 的标签了，SW2 的 e0/3 接收到数据后进行转发，交换机匹配后，e0/0 为 Access 口，对Tag 进行去除，紧着 PC3 收到数据

---

# VTP - VLAN 同步

# 概念

可以从上面的实验中看到，SW1 和 SW2 的配置过程是相当一致的。这就造成了许多重复的工作，为了解决这个问题，可以使用 VTP 协议。

通过 VTP 协议，可以吧一台交换机配置成 VTP Server，其余交换机配置成 VTP Client，这样他们可以自动的学习到 Server 上的 VLAN 信息。

## VTP 域

VTP 域也称为 VLAN 管理域，有一个以上共享 VTP 域名相互连接的交换机组成。也就是说， VTP 域是一组 VTP 域名相同并通过中继链路相互连接的交换机

## VTP 模式

服务器模式

* 提供 VTP 消息，包括 VLAN ID 和名字信息
* 学习相同的域名的 VTP 消息
* 转发相同域名的 VTP 消息
* 可以添加、删除、更改 VLAN

客户机模式

* 请求 VTP 消息
* 学习相同的域名的 VTP 消息
* 转发相同域名的 VTP 消息

> 能同步 VLAN 给服务器，可用于备份（要求是修订版本大于服务器修订版本）

透明模式

* 可以在本地增删改 VLAN
* 转发 VTP 消息

## VTP 配置

![VTP]({{site.baseurl}}/assets/img/VTP.png)


```
// 配置 PC1 - PC4

// 配置 SW1 做  vtp server
Switch(config)#vlan 10,20
Switch(config-vlan)#int e 0/0
Switch(config-if)#switchport mode access
Switch(config-if)#switchport access vlan 10
Switch(config-if)#no shutdown
Switch(config-vlan)#int e 0/1
Switch(config-if)#switchport mode access
Switch(config-if)#switchport access vlan 20
Switch(config-if)#no shutdown
Switch(config-vlan)#int e 0/2
Switch(config-if)#switchport trunk encapsulation dot1q
Switch(config-if)#switchport mode trunk
Switch(config-if)#no shutdown 

Switch(config)#vtp domain icnd1
Switch(config)#vtp mode server

Switch(config)#do write

Switch(config)#do show ip int brief
Switch(config)#do show vlan brief


// 配置 SW3 做 transparent 
Switch(config)#vlan 10
Switch(config)#vlan 20

Switch(config)#vtp domain icnd1
Switch(config)#vtp mode transparent

Switch(config)#int range e 0/2-3
Switch(config-if-range)#switchport trunk encapsulation dot1q
Switch(config-if-range)#switchport mode trunk
Switch(config-if-range)#no shutdown 

Switch(config)#do write

// 配置 SW2 做 client，不需要创建 vlan
Switch(config)#vtp domain icnd1
Switch(config)#vtp mode transparent
Switch(config-vlan)#int e 0/0
Switch(config-if)#switchport mode access
Switch(config-if)#switchport access vlan 10
Switch(config-if)#no shutdown
Switch(config-vlan)#int e 0/1
Switch(config-if)#switchport mode access
Switch(config-if)#switchport access vlan 20
Switch(config-if)#no shutdown
Switch(config-vlan)#int e 0/3
Switch(config-if)#switchport trunk encapsulation dot1q
Switch(config-if)#switchport mode trunk
Switch(config-if)#no shutdown 
Switch(config)#do write

// VTP 是默认开启的，也可以关闭
Switch(config-if)#switchport nonegotiate
```




