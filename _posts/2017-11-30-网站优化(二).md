---
layout: post
tags: [js] # add tag
img: luca-bravo-217276-min.jpg
---

* TOC
{:toc}

# 页面渲染的过程分析

在了解网页从接收到的字节流到最终页面呈现的绘制流程后，我们从整体上确定一下能够影响网页绘制的因素。下面是三个解析文件过程的示例。


## 不引入任何外部文件

最简单的网页只包括 HTML 标记；没有 CSS，没有 JavaScript，也没有其他类型的资源。要渲染此类网页，浏览器需要发起请求，等待 HTML 文档到达，对其进行解析，构建 DOM，最后将其渲染在屏幕上，如以下情况：

```html
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Critical Path: No Style</title>
  </head>
  <body>
    <p>Hello <span>web performance</span> students!</p>
    <div><img src="awesome-photo.jpg"></div>
  </body>
</html>
```

![simple-request](/assets/img/15121125638437.jpg)

**T0 与 T1 之间的时间捕获的是网络和服务器处理时间。**在最理想的情况下（如果 HTML 文件较小），我们只需一次网络往返便可获取整个文档。由于 TCP 传输协议工作方式的缘故，较大文件可能需要更多次的往返。因此，**在最理想的情况下，上述网页具有单次往返（最少）关键渲染路径。**

### 结论：

**关键渲染路径：1 条，因为只有一个 HTML 文件**

**关键字节：5kB**

**最短关键路径长度的交互次数：至少一次**

---

## 引入外部 CSS 文件 

这次我们引入 CSS 文件，并保持同一个界面。

```html
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link href="style.css" rel="stylesheet">
  </head>
  <body>
    <p>Hello <span>web performance</span> students!</p>
    <div><img src="awesome-photo.jpg"></div>
  </body>
</html>
```

![外部引用CSS-页面渲染过程](/assets/img/15121133237968.jpg)

我们同样需要一次网络往返来获取 HTML 文档。然后在进行 DOM 构建时，检索到 `<link>` 标记,告知还需要 CSS 文件。这意味着，浏览器需要再向服务器请求并获取 CSS。在请求 CSS 的过程中，DOM 依然可以被继续构建。但是需要注意的是，在形成渲染树前，需要等到 CSSOM 构建完成。因此，这个页面至少需要两次往返才能显示出来。

> CSS 文件同样可能需要多次往返，但重点在于“最少”
> 同时也证明 CSS 文件是一种解释器阻止资源（关键资源）

### 结论：

**关键渲染路径：2 条，一个 HTML，一个 CSS 文件**

**关键字节：5 + 4 kB**

**最短关键路径长度的交互次数：至少 2 次**

---

## 同时引入 CSS 和 JS 文件


接着又引入了 JS 文件

```html
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link href="style.css" rel="stylesheet">
  </head>
  <body>
    <p>Hello <span>web performance</span> students!</p>
    <div><img src="awesome-photo.jpg"></div>
    <script src="app.js"></script>
  </body>
</html>
```

![同时引入JS文件和CSS文件-页面渲染过程](/assets/img/15121145453694.jpg)

这次又添加了 app.js，它既是网页上的外部 JavaScript 资源，又是一种解析器阻止（即关键）资源。

我们同样需要一次网络往返来获取 HTML 文档。然后在进行 DOM 构建时，检索到 `<link>` 标记,告知还需要 CSS 文件，接着浏览器向服务器请求并获取 CSS。DOM 解析器继续构建，当遇到 `<script>` 标签后，糟糕的事情发生了。回想一下，JavaScript 可以查询 CSSOM，这也就意味着在构建出 CSSOM 之前，JS 是不会被执行的（因为 JS 文件较小，所以默认 JS 文件比 CSS 先返回）。JS 不被执行，就意味着 DOM 解析器不能继续构建。这时所有的构建工作都停止了，直到 CSSOM 被构建，`<script>` 被执行，DOM 解析器才继续工作。

通过上面的构建流程，我们可以分析出等待 CSS 文件和构建 CSSOM 的时间就都被浪费了


### 结论：

**关键渲染路径：3 条，一个 html，一个 css， 一个 js 文件**

**关键字节：5 + 4 + 2 kB**

**最短关键路径长度的交互次数：至少 2 次（因为浏览器可以同时下载多个文件）**

---

## 影响页面的渲染的因素

通过对上述案例的分析，我们将优化的过程集中在以下三个方面：

**关键资源**： 可能阻止网页首次渲染的资源。

**关键路径长度**： 获取所有关键资源所需的往返次数或总时间。

**关键字节**： 实现网页首次渲染所需的总字节数，它是所有关键资源传送文件大小的总和。我们包含单个 HTML 页面的第一个示例包含一项关键资源（HTML 文档）；关键路径长度也与 1 次网络往返相等（假设文件较小），而总关键字节数正好是 HTML 文档本身的传送大小。

下面给出的链接是对关键渲染路径的详细介绍

[分析关键渲染路径性能](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/analyzing-crp#performance-patterns)

[优化关键路径](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/optimizing-critical-rendering-path)

---


# 优化分析

## 优化 HTML 从而减小 DOM 的大小

[优化文本资源](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/optimize-encoding-and-transfer#minification-preprocessing--context-specific-optimizations)‘

[Http缓存](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching)

上面给出的链接是谷歌建议的优化方式，下面是对其的简要总结

### 方法一

![注释](/assets/img/15136837345193.jpg)

写注释是一个非常好的习惯，但太多的注释如图中所示，会增大 HTML 文件的大小。所以在传输时，对注释进行优化是一个很好的选择。下面是给出优化后的结果。

![](/assets/img/15136840569143.jpg)

### 方法二

```html
<html>
  <head>
  <style>
     /* awesome-container is only used on the landing page */
     .awesome-container { font-size: 120% }
     .awesome-container { width: 50% }
  </style>
 </head>

 <body>
   <!-- awesome container content: START -->
    <div>…</div>
   <!-- awesome container content: END -->
   <script>
     awesomeAnalytics(); // beacon conversion metrics
   </script>
 </body>
</html>
```

最好的方式就是压缩重复和不必要的数据，优化后的结果

```html
<html><head><style>.awesome-container{font-size:120%;width: 50%}
</style></head><body><div>…</div><script>awesomeAnalytics();
</script></body></html>
```

### 方法三

使用 GZIP 压缩文件

```
gzip object_file
```

关于 GZIP 的解释，可以浏览这个[页面](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/optimize-encoding-and-transfer#minification-preprocessing--context-specific-optimizations)


---

## 优化 CSS

[CSS 优化](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css)

[压缩关键 CSS](https://jonassebastianohlsson.com/criticalpathcssgenerator/)

[使用 ngrok 生成在线的链接](https://ngrok.com/)

[字体的使用](https://css-tricks.com/snippets/css/basics-of-google-font-api/)

[加载字体的方式](https://github.com/typekit/webfontloader)

我们知道 CSS 一种渲染阻塞资源，只有当 CSSDOM 被成功构建时，页面才会被渲染(形成渲染树)，所以优化 CSS 也显得十分重要。上面给出的连接是谷歌推荐优化 CSS 的方法，下面是对其的概要总结。

### 方法一

[使用媒体查询符](https://developers.google.com/web/fundamentals/design-and-ux/responsive/)

```
<link href="style.css" rel="stylesheet">
<link href="print.css" rel="stylesheet" media="print">
<link href="other.css" rel="stylesheet" media="(min-width: 40em)">
<link href="style.css"    rel="stylesheet" media="all">
<link href="portrait.css" rel="stylesheet" media="orientation:portrait">
<link href="print.css"    rel="stylesheet" media="print">
```

当不使用媒体查询符时，浏览器默认会下载所有的 CSS 文件，这就总会导致渲染过程被阻塞。

通过使用媒体查询符，可以更好的明确使用标准的情况，如通过打印显示的情况，通过屏幕方向和大小改变的情况等

### 方法二

在将内容绘制到屏幕上之前，现代浏览器会阻塞在外部 CSS。 这会导致额外的网络延迟，并增加将内容显示在屏幕上的时间。 为了优化渲染时间，如果外部CSS资源很小（或者首次渲染页面需要的 CSS 很大，可以提提炼出关键 CSS），直接[将关键 CSS](https://developers.google.com/speed/docs/insights/InlineCSS)内嵌到 HTML 文档中。 

这是非使用内敛 CSS 的 HTML文件。

```html
<html>
  <head>
    <link rel="stylesheet" href="small.css">
  </head>
  <body>
    <div class="blue yellow big bold">
      Hello, world!
    </div>
  </body>
</html>
```

这是 `small.css` 文件。

```css
.yellow {background-color: yellow;}
  .blue {color: blue;}
  .big { font-size: 8em; }
  .bold { font-weight: bold; }
```

使用内敛 CSS 后的文件。

```html
<html>
  <head>
    <style>
      .yellow {background-color: yellow;}
      .blue {color: blue;}
      .big { font-size: 8em; }
      .bold { font-weight: bold; }
    </style>
    </head>
  <body>
    <div class="blue yellow big bold">
      Hello, world!
    </div>
  </body
```
---

## 优化 JavaScript

[JS优化参考](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/adding-interactivity-with-javascript)

JavaScript 是一种运行在浏览器中的动态语言，它几乎允许对网页行为的每一个方面进行修改。如可以通过在 DOM 树中添加和移除元素来修改内容，可以修改每个元素的 CSSOM 属性。

下面给出一个[例子](https://googlesamples.github.io/web-fundamentals/fundamentals/performance/critical-rendering-path/script.html)，并进行简要的分析：

```html
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link href="style.css" rel="stylesheet">
    <title>Critical Path: Script</title>
  </head>
  <body>
    <p>Hello <span>web performance</span> students!</p>
    <div><img src="awesome-photo.jpg"></div>
    <script>
      var span = document.getElementsByTagName('span')[0];
      span.textContent = 'interactive'; // change DOM text content
      span.style.display = 'inline';  // change CSSOM property
      // create a new element, style it, and append it to the DOM
      var loadTime = document.createElement('div');
      loadTime.textContent = 'You loaded this page on: ' + new Date();
      loadTime.style.color = 'blue';
      document.body.appendChild(loadTime);
    </script>
  </body>
</html>
``` 

正如我们在前面说的那样，JS 修改了文本的内容，还添加新的元素。但需要注意的是，这段脚本文件放在靠近页面的底部，如果将脚本放在 `<span>` 标签之上，就会发现脚本运行失败，提示找不到对 `_span` 标签的引用。这也就证明了当 DOM 解释器遇到 script 标记时，就会停止构建 DOM，去执行 JS，如果此时的 JS 还是外部引入的文件，还需要考虑去下载文件的延迟，这些都会造成浏览器的渲染被阻塞。只有当 JS 引擎执行完毕，DOM 才能恢复构建。

此时，我们多考虑一种常见情况，假如浏览器尚未完成 CSSOM 的下载和构建（比如一个元素应用了外部 CSS 的类，并且脚本要对这个元素进行操作），而此时却要运行脚本，可怕的事情发生了，浏览器将延迟脚本执行和 DOM 构建，直到完成 CSSOM 的下载和构建。如下图所示：

![js-执行情况](/assets/img/15138226516048.jpg)




进而我们可以知道，“优化关键渲染路径”在很大程度上是指了解和优化 HTML、CSS 和 JavaScript 之间的依赖关系。

最后给出关于优化 JS 的几条建议：

* 使用 [window.onload event](https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onload)，它在资源都被加载完成后触发。这样就可以避免由于未构建 CSSOM，而导致浏览器渲染被阻塞
* 使用[defer属性](https://hacks.mozilla.org/2009/06/defer/)，当页面完成解析后才会被执行
*  使用[async属性](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/adding-interactivity-with-javascript#parser-blocking-vs-asynchronous-javascript)，可以告知浏览器在等待脚本时期，不阻塞 DOM 的构建










