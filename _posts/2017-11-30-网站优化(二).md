---
layout: post
tags: [js] # add tag
img: js-head.png
---

# 优化步骤

下面是关于浏览器渲染整个页面的过程 DEMO

![渲染页面DEMO]({{site.baseurl}}/assets/img/15120335971453.jpg)

## 优化 HTML 减小 DOM 的大小

html 对开发者注释的优化,从而降低文本文件大小

---

## 优化 CSS，通过使用 `media` 查询

[响应式布局](https://developers.google.com/web/fundamentals/design-and-ux/responsive/)

---

## 优化 JavaScript

> JavaScript 的渲染过程，在渲染 DOM 节点时，遇到 `<scipt>` 标签就停止 DOM 的构建，等待 JS 引擎去执行脚本，当 JS 引擎结束后，DOM 节点重新构建

[JS优化](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/adding-interactivity-with-javascript)


使用 `onload` 在所有 dom 节点，图片，脚本和链接加载完成后才去执行
`onload` 里的脚本内容，这也就避免了用于请求脚本的内容所花费的时间

在 `script` 标签内使用 `async` 属性，避免阻塞 DOM 的创建

下面简单的给出引入 JS 的形式

1. Blocking: `<script src="anExteralScript.js"></script>`
2. Inline: `<script>document.write("this is an inline script")</script>`
3. Async: `<script async src="anExternalScript.js"></script>`

---

## 总结

我们将在以下三方面进行优化

**关键资源**： 可能阻止网页首次渲染的资源。

**关键路径长度**： 获取所有关键资源所需的往返次数或总时间。

**关键字节**： 实现网页首次渲染所需的总字节数，它是所有关键资源传送文件大小的总和。我们包含单个 HTML 页面的第一个示例包含一项关键资源（HTML 文档）；关键路径长度也与 1 次网络往返相等（假设文件较小），而总关键字节数正好是 HTML 文档本身的传送大小。


---

# 页面渲染的分析

## 不引入任何外部文件

最简单的网页只包括 HTML 标记；没有 CSS，没有 JavaScript，也没有其他类型的资源。要渲染此类网页，浏览器需要发起请求，等待 HTML 文档到达，对其进行解析，构建 DOM，最后将其渲染在屏幕上，比如如下代码情况：

```html
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Critical Path: No Style</title>
  </head>
  <body>
    <p>Hello <span>web performance</span> students!</p>
    <div><img src="awesome-photo.jpg"></div>
  </body>
</html>
```

![simple-request]({{site.baseurl}}/assets/img/15121125638437.jpg)

**T0 与 T1 之间的时间捕获的是网络和服务器处理时间**。在最理想的情况下（如果 HTML 文件较小），我们只需一次网络往返便可获取整个文档。由于 TCP 传输协议工作方式的缘故，较大文件可能需要更多次的往返。因此，**在最理想的情况下，上述网页具有单次往返（最少）关键渲染路径。**

### 分析结论：

**关键渲染路径：1 条，因为只有一个 html 文件**

**关键字节：5kB**

**最短关键路径长度的交互次数：至少一次**

---

## 引入外部 CSS 文件 

这次我们引入 CSS 文件，还保持同一个界面

```html
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link href="style.css" rel="stylesheet">
  </head>
  <body>
    <p>Hello <span>web performance</span> students!</p>
    <div><img src="awesome-photo.jpg"></div>
  </body>
</html>
```

![外部引用CSS-页面渲染过程]({{site.baseurl}}/assets/img/15121133237968.jpg)

我们同样需要一次网络往返来获取 HTML 文档，然后进行 DOM 构建时，检索到标记告诉我们还需要 CSS 文件；这意味着，浏览器需要再向服务器请求并获取 CSS，这时 DOM 可以接着被构建，但是要等到 CSSOM 也构建完成，然后才能在屏幕上渲染网页。因此，这个页面至少需要两次往返才能显示出来。CSS 文件同样可能需要多次往返，因此重点在于“最少”

### 分析结论：

**关键渲染路径：2 条，因为只有一个 html，一个 css 文件**

**关键字节：5 + 4kB**

**最短关键路径长度的交互次数：至少 2 次**

---

## 同时引入 CSS 和 JS 文件


这次我们引入 CSS 文件和 JS 文件，还保持同一个界面

```html
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link href="style.css" rel="stylesheet">
  </head>
  <body>
    <p>Hello <span>web performance</span> students!</p>
    <div><img src="awesome-photo.jpg"></div>
    <script src="app.js"></script>
  </body>
</html>
```

![同时引入JS文件和CSS文件-页面渲染过程]({{site.baseurl}}/assets/img/15121145453694.jpg)

这次添加了 app.js，它既是网页上的外部 JavaScript 资产，又是一种解析器阻止（即关键）资源。更糟糕的是，为了执行 JavaScript 文件，我们还需要阻塞页面（DOM 构建停止）并等待 CSSOM，首先由于 JS 文件较小所以比 CSS 文件更早的返回，等待时间加上构建 CSSOM 的时间就被浪费了；回想一下，JavaScript 可以查询 CSSOM，因此在下载 style.css 并构建 CSSOM 之前，浏览器将会暂停。最后当 JS 被执行完后，DOM 接着被构建。

### 分析结论：

**关键渲染路径：3 条，因为只有一个 html，一个 css， 一个 js 文件**

**关键字节：5 + 4 + 2kB**

**最短关键路径长度的交互次数：至少 2 次（因为浏览器可以同时下载多个文件）**

---

# 优化文档参考

[优化文本](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/optimize-encoding-and-transfer#text-compression-with-gzip)

[利用HTTP缓存](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching)

[分析关键渲染路径性能](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/analyzing-crp#performance-patterns)

[优化关键路径](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/optimizing-critical-rendering-path)




