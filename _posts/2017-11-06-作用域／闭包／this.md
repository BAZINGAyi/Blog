---
layout: post
tags: [js] # add tag
img: js-head.png
---

# 作用域／闭包／this

## 作用域

**左图为 Lexical Scope(词法作用区)，右图为对应的实际数据存储区**

<img src="{{site.baseurl}}/assets/img/15099472200386.jpg" alt="zuoyongyu"/>

> aHero()、aFoli()、aDeed 为随机产生字符串的函数
> 通过上图我们可以更好的理解实际的执行过程，可以明显的看到，由相同函数定义的同种颜色区域，实际开辟的区域不同。

四次打印 log 的结果是：

1. GelEyesCow
2. GelTipsCow
3. GalRubsCat
4. GalRobsCat

---

## 闭包

> 闭包是指一些函数通过某种方式，可以随时被访问，即使他的外部代码已经被执行完毕

> A closure is just any function that somehow remains available after those outer scopes have returns

### 举例

<img src="{{site.baseurl}}/assets/img/15099486830229.jpg" alt="closure-1"/>

五次打印 log 分别如图所示，两次 `newSage()` 的执行存放了自己的作用域，虽然两次执行的是同一个函数。


### 结论

<img src="{{site.baseurl}}/assets/img/15099483916324.jpg" alt="closure-2" width="40%"/>


**采用什么方式，能保留已经执行完成的 `newSage()` 函数中对 `sage()` 的引用**


结论：

1. 将 `sage` 传入 `setTimeout`
2. 将 `newSage` 函数中返回 `sage`
3. 将 `sage` 保存为全局变量

---

## this

> 在函数没有被具体**调用**之前。是无法知道参数会绑定什么值的


<img src="{{site.baseurl}}/assets/img/15099524968850.jpg" alt="this"/>

**参数 `this`，绑定的对象在大多数的情况下是 . 符号左面调用的对象。（注意大多数）**

如 `obj.fn(3,4);` 函数 `fn` 中的 `this` 绑定对象就是 `obj`.

---

**使用 `call` 函数可以重写默认的全局对象绑定，可以将 `this` 绑定到我们传入的任何一个值上**

---

**在回调函数的绑定，这时就属于少数的情况，你可以传入一个带点符号的执行对象，但是实际上还是 `this`，还是不会绑定传入的对象**











