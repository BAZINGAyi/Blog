---
layout: post
tags: [web] # add tag
img: luca-bravo-217276-min.jpg
---

* TOC
{:toc}

# Pipeline - Javascript 的优化

## Just In Time

Javascript 的代码不会被浏览器直接执行，而是通过 JavaScript 引擎会将代码一个字节一个字节的重新编译，从而使代码运行的更快。这种引擎就是 Just In Time，JIT。

## Javascript 分析

我们已经知道，Javascript 可以引发渲染管道内这些操作（style,layout,paint,compositing），所以，如果能在每一帧开始的时候，尽早的去执行 JavaSctipt，将对网站的性能很大的提升。

在之前，已经谈到过，要想保证浏览器的流畅性，浏览器需要在 1s 之内渲染出 60 帧，也就是说大约需要 16ms 的时间去渲染一帧，但是浏览器还有别的事情需要做，这时的时间花费就被压缩到 10ms 左右。

而 JavaSctipt 代码的执行大约最多有 3 或 4 ms 去执行，因为还需要去做其他的工作如 style calculations，layer management，compositing 等任务，进而合理的使用 JavaSctipt 十分重要。

### 创建动画的好工具-RequestAnimaionFrame

先来回想一下每一帧在渲染时，Pipeline 管道的执行顺序，理想情况下是按照顺序一直执行。

![situation-1](/assets/img/15127162173224.jpg)

但假如我们考虑一下这种情况：

浏览器在计算一些关于 style 的工作时遇到了 Js 代码。浏览器就停下当前的任务，去执行 JavaSctipt 的工作。而 JavaSctipt 可能会引发一些 style 重新绘制的工作，也就造成这一帧需要从头开始计算，也就意味着可能丢失这一帧。


[RequestAnimaionFrame](https://gist.github.com/paulirish/1579671)的出现就解决了这一问题，它保证将 JavaSctipt 尽可能的在每一帧的渲染前面执行，避免 pipeline 执行工作的重复。


> 但是在一些老的 web 代码中，使用 `setTimeout` 或者 `setInterval` 来处理动画问题。JQuery 甚至现在还在使用。而这两个方法的问题是，并不会注意渲染管道的绘制顺序

---

# Web Workers

[Web Workers—MDN](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)

[Web Workers—rocks](https://www.html5rocks.com/en/tutorials/workers/basics/)


## JavaScript Concurrency 的问题

有很多瓶颈的问题阻止着很多有意义的应用从负载的服务器移植到 Javascript 客户端。这些问题包括浏览器的稳定性，静态类型，可达性和性能表现。幸运的是，当浏览器供应商快速的改善 JavaScript 引擎速度，后面这些问题快速成为了过去。

被保留下来较难处理的一件事，实际上就是 JavaScript 这门语言自己。JS 运行在一个单线程的环境，这也就意味着不能在同一时间运行多个脚本语言。举一个例子来说，想象有这么一个网站，它需要处理 UI，查询和加载大量的 API 返回的数据，并且还要操作 DOM。这是很常见的吧，不幸的是这些事件由于浏览器运行 JS 的限制不能同时执行。脚本只能发生在单线程中。

开发者为了模拟并发通过像 `setTimeout()`，`setInterval()`,`XMLHttpRequest`这些技术来处理事件。是的所有的这些技术的特性都是异步运行的，但是不会阻塞并不意味着并发。在当前的脚本执行完成后异步事件才会被处理。好消息是 H5 给我们提供了一些更好的方式。

## Web Worker 介绍

Web Worker 标准定义是一个为了在 Web 应用上，在后台运行脚本的 API。Web Worker 允许你产生一个需要长时间运行用于计算目标任务的脚本，而且这个脚本并不会阻塞 UI 或者其他用于处理用户交互的脚本。

Workers 利用类似于消息传递这样的线程来达到并发。完美的保证了 UI 的刷新，性能和用户的响应。

值得我们注意的是 Web Workers 的两种类型，`Dedicated Worked` 和 `Shared Workers`。暂时我们只先讲述 `Dedicated Worked`，并用Web worker 或者 workers 来代替，用于贯穿全文。

Web Worker 的工作原理：

![Web Worker](/assets/img/15129759785847.jpg)

## 开始

Web Works 运行在一个隔离的线程。这就意味着，代码需要写在另一个的文件中去执行。在我们写之前，第一件事就是创建一个新的 worker 对象在主要的页面中。构造器去一个 work 脚本的名字：

```js
var worker = new Worker('task.js');
```

如果引入的文件是存在的，浏览器将会产生一个新的 worker 线程，并且会异步的下载文件。worker 的执行是在该文件被完全下载和执行完成。如果下载的路径返回 404，worker 将会安静的失败。

在创建 worker 后，开始 worker 的方法叫 `postMessage()`:


```js
worker.postMessage();
```

## 与消息传递的 Worker 进行通信

worker 和 父亲页面的通信，通过使用事件模型和 `postmessage()` 完成。根据浏览器的不同，`postmessage()` 可以接收 string 或者 JSON 对象作为参数。在最近的浏览器版本中支持传递一个 JSON 对象。

下面一个例子是通过传递一个 string `Hello World` 给 worker。worker 在简单的返回传递给它的消息。

Main script:

```js
var worker = new Worker('doWork.js');

worker.addEventListener('message', function(e) {
  console.log('Worker said: ', e.data);
}, false);

worker.postMessage('Hello World');
```

doWork.js:

```js
self.addEventListener('message', function(e) {
  self.postMessage(e.data);
}, false);
```

当 `postmessage()` 从主页面被调用时，worker 会通过定义一个处理 message 事件的 onmessage 处理程序处理这个 message。该消息（这里是'Hello World'）可以在进入 `Event.data` 后被有效加载。

消息在主页面和 workers 传递时会被复制，而不是共享。举个例子，在下面的例子中 JSON message 中的 `msg` 属性可以在两个位置中进入。它发生在对象被直接传递给 worker 即使它们时分开运行的专用空间。事实上，当传递给 work 时，发送的对象被序列化，然后被反序列化。页面和 worker 不会分享相同的实例，所以在每一次传递时都被拷贝一份。大多数浏览器实现特性通过在两端自动进行 JSON 解析和反解析。

下面是一个稍微些复杂的例子：

Main script

```js
<button onclick="sayHI()">Say HI</button>
<button onclick="unknownCmd()">Send unknown command</button>
<button onclick="stop()">Stop worker</button>
<output id="result"></output>

<script>
  function sayHI() {
    worker.postMessage({'cmd': 'start', 'msg': 'Hi'});
  }

  function stop() {
    // worker.terminate() from this script would also stop the worker.
    worker.postMessage({'cmd': 'stop', 'msg': 'Bye'});
  }

  function unknownCmd() {
    worker.postMessage({'cmd': 'foobard', 'msg': '???'});
  }

  var worker = new Worker('doWork2.js');

  worker.addEventListener('message', function(e) {
    document.getElementById('result').textContent = e.data;
  }, false);
</script>
```

doWork.js

```js
self.addEventListener('message', function(e) {
  var data = e.data;
  switch (data.cmd) {
    case 'start':
      self.postMessage('WORKER STARTED: ' + data.msg);
      break;
    case 'stop':
      self.postMessage('WORKER STOPPED: ' + data.msg +
                       '. (buttons will no longer work)');
      self.close(); // Terminates the worker.
      break;
    default:
      self.postMessage('Unknown command: ' + data.msg);
  };
}, false);
```

> 有两种方法能停止 worker 分别是在外部的 worker.terminate() 和 内部的 self.colse()

## Transferrable objects

大多数的浏览器实现的是[结构化的克隆算法](https://developers.google.com/web/updates/2011/09/Workers-ArrayBuffer)，也就允许在 IO 上可以传递更多复杂的类型，如文件，Blob，ArrayBuffer和 JSON 对象。然而当使用 `postMssage()`方法传递着这类类型的参数时，仍然每次都需要拷贝。如果你传递一个 50M 的文件，这里有就产生一个明显的开销在 worker 和主线程中。

结构化的拷贝是好的，单也意味着可能会花费上百毫秒的时间。为了应付性能的瓶颈，可以使用 Transferable Objects.

在 Transferable Objects 对象中，数据从一个上下文转换到另一个上下文，这是零拷贝的，很好的改善了发送数据给 Worker 的性能问题。如果学习过 C/C++ 可以通过引用传递。然而，不像引用传递，来自调用上下文的'version'在转换成新的上下文后便不再可用。例如当从一个 main app 中的 ArrayBuffer 转换到 worker 后，初始的 ArrayBuffer 会被清空并且不再可用。

使用 transferrable objects 与 postMessage 有轻微的不同

```js
worker.postMessage(arrayBuffer, [arrayBuffer]);
window.postMessage(arrayBuffer, targetOrigin, [arrayBuffer]);
```

在这种情况下，第一个参数是数据，第二个参数是需要被转换的项目列表。第一个参数不一定是 ArrayBuffer，也可像下面是 JSON 对象

```js
worker.postMessage({data: int8View, moreData: anotherBuffer},[int8View.buffer, anotherBuffer]);
```

比较值得注意的是，第二个参数必须是 ArrayBuffer 的数组

[Transferable Demo](http://html5-demos.appspot.com/static/workers/transferables/index.html)

## Worker 的作用域

### Worker Scope

在 Worker 的上下文中，`self` 和 `worker` 都表示 worker 在全局范围内的引用，之前的例子还可以写成

```JS
addEventListener('message', function(e) {
  var data = e.data;
  switch (data.cmd) {
    case 'start':
      postMessage('WORKER STARTED: ' + data.msg);
      break;
    case 'stop':
  ...
}, false);
```

同样的，也可以直接使用 `onmessage` 事件处理
```JS
onmessage = function(e) {
  var data = e.data;
  ...
}
```

### Worker 能使用的特性

由于某些对象多线程的行为，web worker 只能使用某些 JavaScript 的特性如：

* The navigator object
* The location object (read-only)
* XMLHttpRequest
* setTimeout()/clearTimeout() and setInterval()/clearInterval()
* [The Application Cache](https://www.html5rocks.com/en/tutorials/appcache/beginner/)
* Importing external scripts using the importScripts() method
* [Spawning other web workers](https://www.html5rocks.com/en/tutorials/workers/basics/)

不能使用对象为：

* The DOM (it's not thread-safe)
* The window object
* The document object
* The parent object

### 使用 Worker 加载外部的脚本

在 Worker 内可以通过 `importScripts` 加载外部的脚本文件或库文件

work.js

```js
importScripts('script1.js');
importScripts('script2.js');
```

也可以这样写

```js
importScripts('script1.js', 'script2.js');
```



---

# JS Memory Management

补充一下 关于 JS 内存管理的问题：

[Writing Fast, Memory-Efficient JavaScript on Smashing Magazine](https://www.smashingmagazine.com/2012/11/writing-fast-memory-efficient-javascript/)

[Memory Management on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management)

[High-Performance, Garbage-Collector-Friendly Code on Build New Games](http://buildnewgames.com/garbage-collector-friendly-code/)


