---
layout: post
category: "web"
---

# Java 编程规约（一）
## 一、编程规约
1. 长量命名全部大写,单词间用下划线隔开，**语义表达清楚**：``MAX_STOCK_COUNT``


2. 抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名使用以它要**测试的类的名称**开始，以 Test 结尾。


3. 数组定义：``String [] args；```。


4. POJO 类中**布尔类型**的变量都不加 is。


5. 包名小写，点分隔符之间有且仅有一个自然语义的英语单词。报名统一使用单数形式（有复数含义，类名可以使用复数形式）如：com.alibaba.open.util


6. 杜绝不规范的缩写 如：AbstractClass ，代码自解释：如从远程仓库拉取代码：PullCodeFromRemoteRepository


7. 如果模块、接口、类方法中是用来设计模式，在命名中体现出设计模式

        ```
          public class OrderFactory；
          public class LoginProxy；
          public class ResourceObserver;
        ```

8. 接口类中的方法和属性不要加任何修饰符号，并加上有效的 Javadoc 注释，尽量不要在接口里定义变量，**如果一定要，肯定是与接口方法相关，并且是整个应用的基础常量**
9. 接口和实现类的命名规则：

    对于 Service 和 DAO 类，基于 SOA（Service oriented Architecture）的理念，暴露出的服务一定为接口，内部的实现类用 Impl 的后缀与接口区别。如：CacheServiceImpl 实现 CacheService

    对于形容能力的接口名称，取对应的形容词做接口名。如 AbstractTranslator 实现 Translatable

10. 枚举类名带有 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。（枚举其实就是特殊的常量类，且构造方法被默认强制是私有。）如： 枚举名字为 ProcessStatusEnum。成员名称：SUCEESS / UNKOWN_REASON。


11. 命名规约：
    1. Service/DAO 层方法命名规约
        1. 获取单个对象的方法用 get 做前缀
        2. 获取多个对象的方法用 list 做前缀
        3. 获取统计值的方法用 count 做前缀
        4. 插入的方法用 save/insert 做前缀
        5. 删除的方法用 remove/delete 做前缀
        6. 修改的方法用 update 做前缀
    2. 领域模型命名规约
        1. 数据对象（数据表）: xxxDO
        2. 数据传输对象（业务领域相关的名称）: xxxDTO
        3. 展示对象: xxxVO
        4. POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO

## 二、常量定义
#### 不允许任何魔法值（即未经定义的常量）直接出现在代码中。如:

    ```
    String key = “Id#taobao” + tradeId; cache.put(key, value);
    ```

**long 或着 Long初始赋值时，使用大写的 L，不能是小写的 l**

**不要使用一个常量累维护所有的常量，按常量功能进行归类，分开维护**

    ```
    //缓存常量放在类 CacheConsts 下
    //系统配置相关常量放在类 ConfigConsts 下
    ```

**常量的复用层次有五层：跨应用共享常量，应用内共享常量，子工程内共享常量，包内共享产量、类内共享常量**
1. 跨应用共享常量：放置在二方库中，通常为 client.jar 中的 constant 目录下
2. 应用内共享常量，放置在一方库中，通常为 modules 中的 constant 目录下（通俗易懂也要统一定义成应用内共享常量，如定义 ‘YES’ 等）
3. 子工程内部共享常量：即在当前子工程下的 constant 目录下
4. 包内共享常量：当前下包下单独的 constant 目录下
5. 类内共享常量：直接在类内部 private static final 定义


**如果变量仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类**

```
//如定义星期几
public Enum { MONDAY(1), TUESDAY(2),WEDNESDAY(3),THURSDAY(4),THURSDAY(4),FRIDAY(5),SATURDAY(6)},SUNDAY(7);}
```

## 代码格式
**大括号的使用约定**
  1. 大括号内为空，则简洁地写成{}
  2. 左大括号前不换行
  3. 右大括号前换行
  4. 右大括号后还有 else 等代码则不换行；表示终止的右大括号后必须换行

**if/for/while/switch/do 等保留字与括号之间必须加空格**

**任何二目、三目运算符的左右两边都需要加一个空格 +-*／&&**

**左小括号和字符之间不出现空格，右小括号和字符之间不出现空格**

**采用 4 个空格缩紧，禁止使用 tab 字符**

**注释的双斜线与注释内容之间有且仅有一个空格**

**方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行**

###OOP规约
**禁止通过一个类的对象引用访问此类的静态变量或静态方法**

**相同类型参数，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object**

**外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生特殊的影响**

> 方法过时必须加 @Deprecated 注释

**不能使用过时的类或方法**

**使用常量或确定的值的对象来调用 equals()**

**所有的相同类型的包装类（基本数据类型对应的类，如 boolean -> Boolean）对象之间值的比较，全都使用 equals 方法比较**

**基本数据类型和包装的数据类型的使用标准**



**定义 DO／DTO／VO 等 POJO 类时，不要设定任何属性默认值**

**序列化类新增属性时，不要修改 serialVersionUID 字段，避免反序列化失败；如果完全不兼容升级，避免反序列化混乱，请修改 serialVersionUID 的值**

**构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中**

**POJO 类必须写 toString 方法，方便抛出异常时，可以调用方法排查问题**

**使用索引访问懂 String.split 方法得到的数组时，需做最后一个分隔符后又无内容的检查**

    ```java
    String str = "a,b,c,,";
    String[] ary = str.split(",");
    System.out.println(ary.length);
    // 结果是 3
    ```

**当一个类有多个构造方法，或有多个同名方法，这些方法应该按顺序放置在一起，优先级大于 14 条**

**类内方法的定义顺序依次是：共有方法或保护方法 > 私有方法 > getter/setter 方法**

**setter 方法中，参数名称与类成员变量名称一致，在 getter 和 setter 方法中，不增加业务逻辑**
    
    ```java
    // 错误示范
    public Integer getData() {
        if (true) {
            return this.data + 100; // 错误增加了业务逻辑
        } else {
            return this.data - 100;
        }
    }
    ```

**循环体内，字符串的连接方式，使用 StringBuilder 的 append 进行扩展**
> 反编译出的字节码文件显示出每次循环都会 new 一个 stringBuffer 对象，然后进行 append 操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费

**final 可以声明类、成员变量、方法、以及本地变量、下列为具体的使用规则**
1. 不允许被继承的类，如 String 类
2. **不允许修改引用的域对象，如： POJO 类的域变量 （暂未清楚）**
3. 不允许被重写的方法，如：POJO 类的 setter 方法
4. 不允许在运行过程中重新赋值的局部变量
5. 避免上下文重复使用一个变量，使用 final 可以强制重新定义一个变量，方便更好的重构

**慎用 Object 的 clone 方法来拷贝对象**
> 对象的 clone 方法默认是浅拷贝，若想实现深拷贝需要重写 clone 方法实现属性对象的拷贝。

**类成员与方法访问控制从严**
1. 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private
2. 工具不允许有 public 或 default 构造方法
3. 类非 static 成员变量并且与子类共享，必须是 protectd
4. 类非 static 成员变量并且仅在本类使用，必须是 private
5. 类 static 成员变量如果仅在本类使用，必须是 private
6. 若是 static 成员变量，必须考虑是否是 final
7. 类成员方法只提供类内使用，必须是 private


**类成员方法只对继承类公开，限制为 protected**









