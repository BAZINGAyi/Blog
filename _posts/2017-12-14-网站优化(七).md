---
layout: post
tags: [js] # add tag
img: luca-bravo-217276-min.jpg
---

[TOC]

# Pipeline - Layout 优化

[在 WebKit 会触发 layout 的操作](http://gent.ilcore.com/2011/03/how-not-to-trigger-layout-in-webkit.html)

[CSS 触发管道的操作](https://csstriggers.com/border-bottom-style)

![pipeline](/assets/img/15132320495017.jpg)


我们要尽量保证页面的渲染按照 pipeline 的顺序，下面将给出一个错误示范，没有按照 pipeline 的顺序而导致花费了大量的时间，这是进行测试的[网址](http://output.jsbin.com/aqavin/2/quiet)，该网站是通过控制绿色条块大长度而对下面的文字的宽度进行控制

先来尝试一下错误的代码写法，使用 chrome 中的 Performance 进行 pipeline 绘制分析

![](/assets/img/15132326614498.jpg)


可以看到，chrome 中绘制出现了大量的警告，接着我们分析可能会导致问题的代码时

```js
 document.querySelector('.set-size').addEventListener('click', function(event) {
    // get all the paragraphs
    var ps = document.querySelectorAll('.lipsum-blocks p');
    var i = ps.length;
    // Shall we take the slow path
    // Assumes the select element is straight after the button
    var goSlow = !!this.nextElementSibling.value;
    var size;
    
    if (goSlow) {
      while (i--) {
        // looking at the sizer's offsetWidth on each loop - this is the slow bit
        ps[i].style.width = sizer.offsetWidth + 'px';
      }
    }
    else {
      // cache the sizer's width, this avoids multiple layouts
      size = sizer.offsetWidth;
      while (i--) {
        ps[i].style.width = size + 'px';
      }
    }
    event.preventDefault();
  });
```

我们发现，当选择 goSlow 时，先是通过 `sizer.offsetWidth` 获取绿色长条的宽度，而该操作是需要 进行 Layout 绘制的，也就是说将 Layout 放到了 JS 部分去执行，这样做本身不引发太大问题，可是接下来的操作是改变每个段落的宽度大小，该操作则会 引发 style 的改变，进而又进行一次 layout 的计算。问题更大的是，还在一个循环中进行，这也就导致了卡顿，下面的绘制图也证明了我们的看法

![error-wirte](/assets/img/15132335217276.jpg)


再来分析一下正确的写法，下面同样是点击改变后的 pipeline 渲染过程，仅仅将 `sizer.offsetWidth` 调整下位置，就可以造成这么大的区别

![correct](/assets/img/15132337508653.jpg)



