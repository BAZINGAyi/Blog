---
layout: post
tags: [network] # add tag
img: internet.jpg
---

# 同网段的数据通信

![experience]({{site.baseurl}}/assets/img/experience.png)

> 把路由器的路由功能关闭，这里的 R1 代表的就是 PC 了，否则是 Ping 不通的

> 这里出现的设备均是第一次启动

> 利用交换机和 ARP 知识内容，如果不清楚，请移步上篇文章

使用 `ping` 命令进行测试

这里 R1 想要给 PC 发送 **IP 数据包**，只有按照要求封装成 2 层数据帧的格式才可以。这时发现目前有源 MAC 地址，却没有目的 MAC 地址，那么封包不成功，暂时将包搁置。接着发送 ARP 广播（将 ARP 广播添加帧头部发送,帧结构如下图）

![同网段通信]({{site.baseurl}}/assets/img/J%5B%25%7D9JNPI%60HUMWJ7%7DVWSHAJ%202.png)

交换机收到该数据包后发现目的 MAC 为 ffff:ffff:ffff, 根据交换机的转发规则，先将 R1 的源 MAC 和自己端口号（e0/0）存入 MAC 表，然后进行泛洪操作，广播到该网络的每一个主机。每个主机收到后开始解封装，进而查看到 ARP 报文中的目的 IP，PC 发现 目的 IP 和自己的 IP 一致，接着发送 ARP 响应报文（如下图）

![ARP响应报文]({{site.baseurl}}/assets/img/%7D9$VB%7DKPI1C@3H%7B5%5D1%5BW-%7BS.png)

交换机收到 PC 的 ARP 应答报文后，由于要去的 MAC 地址自己本身的 MAC 表里已经存在，进而直接转发给 R1。R1 收到 PC 的响应报文后，开始解封装，并查看 ARP 报文中的目的 MAC，添加到搁置的缺少目的 MAC 的数据包，接着将封装好的数据帧发送到 PC (ping 命令 在传输层是 ICMP 协议)

![ICMP]({{site.baseurl}}/assets/img/ICMP.png)

---

# 不同网段之间的通信

![ARP-OVER-Internet]({{site.baseurl}}/assets/img/ARP-OVER-Internet.png)

> 这里注意一下，两台 PC 机要配置网关，否则 ARP 包内的内容可能不一样
> 不管终端的目的是哪里，首先都要将数据包发送到网关

PC1 要给 PC2 发送 ICMP 包，首先要发送到网关，我们先模拟下封包过程：
封装 4 层 ICMP 头
封装 3 层 IPV4 头，源 IP 为 12.1.1.1 目的 IP 为 23.1.1.2
封装 2 层 头，源 MAC 为 aabb.cc00.1000 目的 MAC（也就是网关的 MAC） **不清楚**
封包暂停

PC1 开始发送 ARP 报文，获取网关 MAC，报文如下：

![arp-pc1发]({{site.baseurl}}/assets/img/1.png)

路由器 R2 收到 ARP 请求报文，开始解封装，发现报文中的 Sender IP 是自己，那么进行 ARP 报文回复，并将 PC1 的源 MAC 和源 IP 记录在自己 ARP 缓存表中，报文如下：

![arp-回复pc1]({{site.baseurl}}/assets/img/2.png)


PC1 收到 ARP 应答报文，进行进行解封装，取出报文中的缺少的 MAC 地址，添加到搁置的 ICMP 的包中，PC1 顺利的将数据包发送至网关

R2 收到发来的 ICMP 包后，进行解封装，进行到第三层时，发送目的 IP 是自己可达网段中的 IP。因此进行转发，开始封装新的 ICMP 数据![](/assets/img/15113277923298.jpg)包

封包过程如下，三层不变
封装二层，封装源  MAC：aabb.cc00.2010 ，目的 MAC （PC2 终端 MAC）**不清楚**
封包暂停

R2 开始发送 ARP 报文，请求 PC2 的 MAC 地址，报文如下：

![R2-请求arp]({{site.baseurl}}/assets/img/3.png)


交换机收到 ARP 请求报文，将 R2 的 e0/1 的 MAC 地址和自己的端口号(e0/0) 记录在 MAC 地址表内，然后根据规则进行泛洪

PC2 收到 ARP 解析包后，发送 ARP 包中的目的 IP 是自己，因此进行 ARP 应答，并将 ARP 请求中的源 MAC (aa:bb:cc:00:20:10) 和 源 IP(23.1.1.1) 记录在自己的 ARP 缓存表中,应答报文如下：

![pc2-应答arp]({{site.baseurl}}/assets/img/4.png)


交换机收到 PC 的 ARP 应答报文后，先将 PC2 的 e0/0 MAC 地址和自己的端口号(e0/1) 记录字 MAC 地址表内，接着发现要去数据包要去的 MAC 地址在自己的 MAC 表内，因此直接转发

R2 收到 ARP 应答报文，取出 PC2 的 MAC 地址，并添加到搁置的 ICMP 包中，封包成功。接着将 ICMP 包发给 PC2，同时也将 PC2 的 MAC 地址和 IP 记录在自己的 Arp 缓存表中

PC2 收到 ICMP 包发现，三层中目的 IP 是自己，接着进行 ICMP 应答，我们再来模拟一下封包的过程:
封装 4 层 ICMP 头
封装 3 层，源 IP：23.1.11 目的 IP：12.1.1.1
封装 2 层，源 MAC：aabb.cc00.4000 目的MAC：网关 MAC(aabb.cc00.2010)(在 ARP 缓存表中取得)
然后进行发包

交换机收到数据包后，发送目的 MAC 在自己的 MAC 表中有，直接转发给 R2，R2 收到数据包后，解 封 2 层，发现 3 层中要去的网段自己能到达，因此开始封装包：
3 层不变
2 层的源 MAC 为自己的 MAC 地址(e 0/0)，目的 MAC 为 aabb.cc00.1000 (从 Arp 缓存表中取得)，
报文如下：

![ICMP-应答报文]({{site.baseurl}}/assets/img/5.png)

