---
layout: post
tags: [Git] # add tag
img: git_1.png
---

# Git 精简（二）

## Git Tagging

`git tag -a v1.0` **创建一个 Tag 用于标记当前的 commit**

> -a 表示创建的是带注释的 tag ，包含是谁创建，创建饿日期，创建的信息

`git tag` **显示创建的 tag 标签**

> tag 标记的 commit 不会显示在 commit 里

`git log --decorate` **会在显示出的 commit 中，显示 tag 的信息**

`git tag -d v1.0` **删除创建的 tag 标签**

`git tag -a v1.0 SHA` **创建一个 tag 在过去的 commit 上 **

---

## Git 分支

![git_branch]({{site.baseurl}}/assets/img/15091769730484.jpg)

HEAD：是在分支上移动的指针，指向当前的代码线的版本，通常会指向最近的一次 commit，并且在切换分支时，HEAD 也会跟着移动到对应分支上，分支间独立存在，**互不影响(文件的增删改)**。

> 如图中的 MASTER、SIDEBAR、HEADER-FIX 表示不同的分支名称


---

`git branch` **浏览当前的所有分支**

`git branch <branch_name>` **创建一个叫 brance_name 的分支**

`git checkout <branch_name>` **切换到 brance_name 的分支**

---

`git branch -d sidebar` **用于删除分支**

> 分支通常用于 fix project，所以合并分支后可以删除分支

> 不能删除当前所在的分支

> 正常下不能删除未合并的其他分支，会提示 “the xxxbranch  is not fully merged.”，但若想强制删除可以使用 'git branch -D  xxbranch'

---

**实例分析**
描述：在我们实际的工作中，提交了多个 commit 发现其中一个 commit 有错误，要回到之前的 commit 版本，并且将内容全都恢复到该指定 commit 的版本，可以这么做。

准备工作：
1. 新建一个名叫 `project` 的文件夹
2. 使用 `git init` 对其进行初始化
3. 新建 一个名叫 `a.txt` 的文件并在文件中的第一行写上 `I am the first word`
4. 使用 'git add .' 将文件添加到暂存区
5. 使用 'git commit' 将文件提交到仓库

关键来了哦：
6. 创建文件 b.txt 并且修改 `a.txt`中的内容为 'I am the second word'
7. 使用 'git add .' 添加到暂存区
8. 使用 'git commit' 添加到仓库；

这时使用 `git log` ,显示如下：

![example1]({{site.baseurl}}/assets/img/7C588725-B31D-4A12-A526-AC3D0B3BEF5C.jpeg)

这时使用 `git reset c4147c3e3e58b3d91cafedc77770bcbe90c75092` 回到之前的 commit 状态，查看 log 信息,会出现类似 `Unstaged changes after reset: 	a.txt` 的改变提示，这时我们再使用 `git log` 查看一下：

![example2]({{site.baseurl}}/assets/img/5170B5B3-55A2-4E53-98C1-8DDD5A18E3E5.jpeg)

然后开始我们的分析了, `b.txt` 和 `a.txt` 会在工作区还是暂存区还是仓库中呢？并且 `a.txt `的内容是什么呢？

![example3]({{site.baseurl}}/assets/img/D5B90E80-F5FE-4647-BDC2-E1F3D94BD24F.png)

**正如图中显示的那样,** `a.txt`,`b.txt` **均在工作区,接着可以使用** `git diff` 用来查看更加详细的信息如下图

![example4]({{site.baseurl}}/assets/img/C6033C88-7DFA-48A4-930A-36AA503B94AA.png)

**可以看到这时的改变正是最后那次 commit（4a0220fd5e4d418e73c98e9b7ec432be2449f0bb） 记录的内容**

现在可以根据需要删除，或修改的文件了～


---

` git log --oneline --decorate --graph --all` 用于查看仓库的分支状况

---

### Git 合并

![git_merge]({{site.baseurl}}/assets/img/15091971354913.jpg)

**如 8 所在的 commit 所示，合并后会产生一个新的 commit**

`git merge <name-of-branch-to-merge-in>` **进行合并操作**

> merge 后会合并两个分支中分离的代码
> merge 后会创建一个新的commit
> merge 后会整合两个分支上的所有 commit 记录，Head 会指向合并后的相同的分支

---

#### 关于 merge 合并的三种状态

**Fast Forward Merge**

> 如果主分支（master）和新建的分支（new）没有分道扬镳，那么进行的就是一次 Fast Forward Merge，也就是说 new 分支被创建后，master 分支并没有提交什么 commit

<img src="{{site.baseurl}}/assets/img/15092403773415.jpg"  alt="Fast-Merge" width="20%"/>

图中紫色代表 master 分支，绿色代表新的分支 new，可以看到在合并之前master 分支并没有提交任何 commit，所以可以进行快速合并，注意这种情况下的合并是不产生新的 merge commit 的。

但是可以通过` --no-ff` 命令强制生成一个合并 commit，合并的后的效果如下：

<img src="{{site.baseurl}}/assets/img/15092406948311.jpg"  alt="Fast-Merge1" width="10%"/>

-----

**A Regular Merge**

> 如果主分支（master）和新建的分支（new）有分道扬镳（没有冲突发生），那么进行的就是 Regular Merge。

<img src="{{site.baseurl}}/assets/img/15092411595060.jpg"  alt="Typical-Merge1" width="30%"/>

可以看到 master 分支和 new 分支发生了分叉，并且都各自提交了 commit，所以创建了一个新的 merge commit

----


**Conflict Merge** 

> Git 会跟踪文件的每一行，冲突会发生在提取一样的行，但是内容却被改变在不同的分支。比如你在 master 创建了一个新的分支 new，然后在 master 分支中修改了你的信息为"About me",并且提交。这时你又切换到 new 分支，修改相同的地方为"About me information",同时也提交。这时再进行分支的合并时，就会造成冲突，因为 Git 不知道你想保留那个。

制造冲突（默认已经是 git 仓库）：
1. 在 `master` 分支，创建 `a.txt`，并添加内容 `I am word` 并提交。
2. 在 `master` 分支，创建 `new` 分支
3. 在 `master` 分支，修改 `a.txt` 的内容为 `I am the new word`, 提交。
4. 在 `new` 分支，修改 `a.txt` 的内容为 `I am the second word`, 提交。
5. 返回 `master` 分支，合并 `new` 分支。

显示的冲突如下：

```
<<<<<<< HEAD
I am the new word
||||||| merged common ancestors
I am word
=======
I am the second word
>>>>>>> new

```

> <<<<<<HEAD 下面表示当前所在的分支
> |||||| 下面merged common ancestors 表示合并前的共同历史
> ====== 下面表示要和入其他分支的内容


