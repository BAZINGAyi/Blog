---
layout: post
tags: [Git] # add tag
img: git_1.png
---

# Git 精简（二）- 分支

## Git Tagging

`git tag -a v1.0` **创建一个 Tag 用于标记当前的 commit**

> -a 表示创建的是带注释的 tag ，包含是谁创建，创建饿日期，创建的信息

`git tag` **显示创建的 tag 标签**

> tag 标记的 commit 不会显示在 commit 里

`git log --decorate` **会在显示出的 commit 中，显示 tag 的信息**

`git tag -d v1.0` **删除创建的 tag 标签**

`git tag -a v1.0 SHA` **创建一个 tag 在过去的 commit 上**

---

## Git 分支

![git_branch]({{site.baseurl}}/assets/img/15091769730484.jpg)

HEAD：是在分支上移动的指针，指向当前的代码线的版本，通常会指向最近的一次 commit，并且在切换分支时，HEAD 也会跟着移动到对应分支上，分支间独立存在，**互不影响(文件的增删改)**。

> 如图中的 MASTER、SIDEBAR、HEADER-FIX 表示不同的分支名称


---

`git branch` **浏览当前的所有分支**

`git branch <branch_name>` **创建一个叫 brance_name 的分支**

`git checkout <branch_name>` **切换到 brance_name 的分支**

---

`git branch -d sidebar` **用于删除分支**

> 分支通常用于 fix project，所以合并分支后可以删除分支

> 不能删除当前所在的分支

> 正常下不能删除未合并的其他分支，会提示 “the xxxbranch  is not fully merged.”，但若想强制删除可以使用 'git branch -D  xxbranch'

---

`git log --oneline --decorate --graph --all` 用于查看仓库的分支状况

---

### Git 合并

![git_merge]({{site.baseurl}}/assets/img/15091971354913.jpg)

**如 8 所在的 commit 所示，合并后会产生一个新的 commit**

`git merge <name-of-branch-to-merge-in>` **进行合并操作**

> merge 后会合并两个分支中分离的代码
> merge 后会创建一个新的commit
> merge 后会整合两个分支上的所有 commit 记录，Head 会指向合并后的相同的分支

---

#### 关于 merge 合并的三种状态

**Fast Forward Merge**

> 如果主分支（master）和新建的分支（new）没有分道扬镳，那么进行的就是一次 Fast Forward Merge，也就是说 new 分支被创建后，master 分支并没有提交什么 commit

<img src="{{site.baseurl}}/assets/img/15092403773415.jpg"  alt="Fast-Merge" width="20%"/>

图中紫色代表 master 分支，绿色代表新的分支 new，可以看到在合并之前master 分支并没有提交任何 commit，所以可以进行快速合并，注意这种情况下的合并是不产生新的 merge commit 的。

但是可以通过` --no-ff` 命令强制生成一个合并 commit，合并的后的效果如下：

<img src="{{site.baseurl}}/assets/img/15092406948311.jpg"  alt="Fast-Merge1" width="10%"/>

-----

**A Regular Merge**

> 如果主分支（master）和新建的分支（new）有分道扬镳（没有冲突发生），那么进行的就是 Regular Merge。

<img src="{{site.baseurl}}/assets/img/15092411595060.jpg"  alt="Typical-Merge1" width="30%"/>

可以看到 master 分支和 new 分支发生了分叉，并且都各自提交了 commit，所以创建了一个新的 merge commit

----


**Conflict Merge**

> Git 会跟踪文件的每一行，冲突会发生在提取一样的行，但是内容却被改变在不同的分支。比如你在 master 创建了一个新的分支 new，然后在 master 分支中修改了你的信息为"About me",并且提交。这时你又切换到 new 分支，修改相同的地方为"About me information",同时也提交。这时再进行分支的合并时，就会造成冲突，因为 Git 不知道你想保留那个。

制造冲突（默认已经是 git 仓库）：
1. 在 `master` 分支，创建 `a.txt`，并添加内容 `I am word` 并提交。
2. 在 `master` 分支，创建 `new` 分支
3. 在 `master` 分支，修改 `a.txt` 的内容为 `I am the new word`, 提交。
4. 在 `new` 分支，修改 `a.txt` 的内容为 `I am the second word`, 提交。
5. 返回 `master` 分支，合并 `new` 分支。

显示的冲突如下：

```
<<<<<<< HEAD
I am the new word
||||||| merged common ancestors
I am word
=======
I am the second word
>>>>>>> new

```

> <<<<<<HEAD 下面表示当前所在的分支
> |||||| 下面merged common ancestors 表示合并前的共同历史
> ====== 下面表示要和入其他分支的内容


