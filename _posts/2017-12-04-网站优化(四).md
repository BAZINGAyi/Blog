---
layout: post
tags: [web] # add tag
img: luca-bravo-217276-min.jpg
---

* TOC
{:toc}

# 理解浏览器帧的绘制

**帧**就是影像动画中最小单位的单幅影像画面。 一帧就是一副静止的画面，连续的帧就形成动画，如电视图象等。 我们通常说帧数，简单地说，就是在 1 秒钟时间里传输的图片的帧数，也可以理解为图形处理器每秒钟能够刷新几次，通常用FPS（Frames Per Second）表示。

当今绝大多数的设备是每秒 60 次（60 HZ），所以我们要尽可能的提供每秒 60 帧的画面，通常将其称为 60 fps。

接着我们就可以计算出，我们渲染出一帧所需时间为 1000／60 = 16 ms。但实际上，浏览器有整理工作要做，因此您的所有工作需要在 10 毫秒内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动。 此现象通常称为卡顿，会对用户体验产生负面影响。

## 网页的绘制：

在之前的文章中，已经详细的介绍了网页的渲染过程，现在对其简单的概述下：

**首先**浏览器通过向服务器发送请求得到 HTML ，构建 DOM 和 CSSDOM，接着将两者联合形成渲染树

> 形成的渲染树会缺失或增加一些内容，如在 CSS 中被设为 `display:none` 的元素不会在渲染树中，而在 CSS 添加伪元素的元素会被增加到渲染树中，如在 `section h1:after {content: "aaa"}`


![step-1](/assets/img/15138330094798.jpg)


**然后**进行 layout 的绘制,确定元素的位置

![step-2](/assets/img/15123778055757.jpg)

接下来 paint ，由 vector 到 raster 的转变，渲染到每一个像素点上

![setp-3](/assets/img/15123780899771.jpg)

最后，浏览器将绘制的多个图层联合在一起

---

## [渲染管道](https://developers.google.com/web/fundamentals/performance/rendering/?hl=zh-cn)

在了解了浏览器是如何渲染页面后，接着来看一看渲染管道（也叫像素管道），它是作为开发者可以拥有最大控制权的部分。每一帧的画面经过相应的管道步骤后，才最后显示出来，所以，掌握管道的绘制是十分重要的。

如下图所示，这是渲染管道中 5 个主要的区域。

![pipeline 概述](/assets/img/15138343782864.jpg)

* JavaScript。一般来说，我们会使用 JavaScript 来实现一些视觉变化的效果。比如用 jQuery 的 animate 函数做一个动画、对一个数据集进行排序或者往页面里添加一些 DOM 元素等。当然，除了 JavaScript，还有其他一些常用方法也可以实现视觉变化效果，比如：CSS Animations、Transitions 和 Web Animation API。

* 样式计算。此过程是根据匹配选择器（例如 `.headline` 或 `.nav > .nav__item`）计算出哪些元素应用哪些 CSS 规则的过程。从中知道规则之后，将应用规则并计算每个元素的最终样式。

* 布局。在知道对一个元素应用哪些规则之后，浏览器即可开始计算它要占据的空间大小及其在屏幕的位置。网页的布局模式意味着一个元素可能影响其他元素，例如 <body> 元素的宽度一般会影响其子元素的宽度以及树中各处的节点，因此对于浏览器来说，布局过程是经常发生的。

* 绘制。绘制是填充像素的过程。它涉及绘出文本、颜色、图像、边框和阴影，基本上包括元素的每个可视部分。绘制一般是在多个表面（通常称为层）上完成的。

* 合成。由于页面的各部分可能被绘制到多层，由此它们需要按正确顺序绘制到屏幕上，以便正确渲染页面。对于与另一元素重叠的元素来说，这点特别重要，因为一个错误可能使一个元素错误地出现在另一个元素的上层。

**管道在渲染的过程中，每个部分都有机会产生卡顿，因此务必了解到所写的代码可能会触发那样部分**

---

### 管道绘制的三种形式：

每一帧的画面的形成不一定需要，经历管道中的所有部分。通常分为以下三种情况。

#### 第一种：JS / CSS > 样式 > 布局 > 绘制 > 合成

![dynamic-paint-1](/assets/img/15123844298301.jpg)

通过 CSS 或 JS 做出外观的改变（layout），也就是改变了元素的几何属性（例如宽度、高度、左侧或顶部位置等，那么浏览器将必须检查所有其他元素，然后“自动重排”页面。任何受影响的部分都需要重新绘制，而且最终绘制的元素需进行合成。

#### 第二种：JS / CSS > 样式 > 绘制 > 合成

![dynamic-paint-2](/assets/img/15132407671045.jpg)

如果仅仅更改了绘制属性（背景图片，文本颜色或阴影），仅需要更改浏览器受到影响的元素的样式，绘制并合成


#### 第三种：JS / CSS > 样式 > 合成

![dynamic-paint-3](/assets/img/15132407948869.jpg)

如果您更改一个既不要布局也不要绘制的属性，则浏览器将跳到只执行合成。这个最后的版本开销最小，最适合于应用生命周期中的高压力点，例如动画或滚动。

注：如果想知道更改任何指定 CSS 属性将触发上述三个版本中的哪一个，请查看[CSS 触发器](https://csstriggers.com/)。如果要快速了解高性能动画，请阅读[更改仅合成器的属性部分](https://developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count?hl=zh-cn)。
---

# Web 的生命周期

网络应用的四大周期称为[RAIL](https://developers.google.com/web/fundamentals/performance/rail)。Response，Animate，Idle，Load。

## Cycle Rail

Load 状态时，加载必要的数据,在 1 秒中内完成

Idle 状态时，通常有 50ms 的时间去加载因为满足 1 秒钟加载目标而推迟的工作，并且 idle 状态可能出现多次，我们可以利用这段时间来加载繁重的任务

Response 状态时， 对用户的操作进行无延迟的响应，在 100 毫秒内响应

Animate 状态时，渲染一帧的时间是 1000/60 = 16 毫秒，由于浏览器通常也需要进行其他操作，进而使用动画的时间进一步缩短为 12毫秒左右

![cycle-rail](/assets/img/15124532014163.jpg)


### 采用 FLIP 方法使动画达到要求

First 

读取动画前的位置

Last

展开卡片后，读取动画后最终位置

Invert

计算出差异，然后转换到最开始的状态

Play

正常播放动画 

![FLIP](/assets/img/15124566130575.jpg)

![FLIP-actual](/assets/img/15124568820760.jpg)

人类大脑可以忍受 100ms 的停顿时间，当用户点击后，在动画开始前利用这段时间先计算复杂的操作，然后在开始动画，才能够达到 60 fps

---

# 推荐合适的时间操作

![生命周期建议操作](/assets/img/15124587047653.jpg)


[生命周期操作指南](https://speakerdeck.com/paullewis/making-a-silky-smooth-web)





