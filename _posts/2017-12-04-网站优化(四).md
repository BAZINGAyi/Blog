---
layout: post
tags: [js] # add tag
img: js-head.png
---

# 浏览器帧的绘制

## 静态网页的绘制：

首先通过向服务器发送请求得到 html ，构建 DOM 和 CSSDOM，接着将两者联合形成渲染树

> 形成的渲染树会缺失或增加一些内容，如在 CSS 中被设为 `display:none` 的元素不会在渲染树中，而在 CSS 添加伪元素的元素会被增加到渲染树中，如在 `section h1:after {content: "aaa"}`


![step-1](/assets/img/15123767919155.jpg)

进行 layout 的绘制,确定元素的位置

![step-2](/assets/img/15123778055757.jpg)

接下来是由 vector 到 raster 的转变

![setp-3](/assets/img/15123780899771.jpg)

之后浏览器可能会绘制多个图层，最后并把这些图层联合在一起

## 动态网页的渲染管道绘制：

管道绘制绘制的三种形式：

第一种：

* 通过 CSS 或 JS 做出外观的改变，浏览器必须重新计算受到影响的元素的样式
* 如果更改了布局属性，如宽度，高度等，浏览器需要检查页面上的其他元素，受到影响的区域将重现绘制
* 最后将绘制的元素合成到一起

![dynamic-paint-1](/assets/img/15123844298301.jpg)

第二种：

* 如果仅仅更改了绘制属性如背景图片，文本颜色或阴影，仅需要更改浏览器受到影响的元素的样式，绘制并合成

![dynamic-paint-2](/assets/img/15123846415342.jpg)


第三种：仅仅合成

> 合成是指浏览器将网页的单个图层，合成在一起

---

# Web 的生命周期

## Cycle Rail

![cycle-rail](/assets/img/15124532014163.jpg)


{{ "/assets/screenshot.jpg" | absolute_url }}

> 代表 reponse，animations，idle，and load

load 状态时，加载必要的数据,在 1 秒中内完成

idle 状态时，我们通常由 50ms 的时间去加载因为满足 1 秒钟加载目标而推迟的工作，并且 idle 可能出现多次，我们可以利用这段时间来加载繁重的任务

reponse 状态时， 对用户的操作进行无延迟的响应，在 100 毫米内响应

animations 状态时，对用户的响应在 1000/60 = 16 毫秒内响应，由于浏览器通常也需要响应，所以时间进一步缩短为 12  毫米左右

### 采用 FLIP 方法使动画达到要求

First 

读取动画前的位置

Last

展开卡片后，读取动画后最终位置

Invert

计算出差异，然后转换到最开始的状态

Play

正常播放动画 

![FLIP](/assets/img/15124566130575.jpg)

![FLIP-actual](/assets/img/15124568820760.jpg)

> 人类大脑可以忍受 100ms 的停顿时间，在动画开始前利用这段时间先计算复杂的操作，然后在开始动画，才能够达到 60 fps

---

# 推荐合适的时间操作

![生命周期建议操作](/assets/img/15124587047653.jpg)


[生命周期操作指南](https://speakerdeck.com/paullewis/making-a-silky-smooth-web)





