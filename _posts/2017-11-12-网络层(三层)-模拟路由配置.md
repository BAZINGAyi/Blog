---
layout: post
tags: [network] # add tag
img: internet.jpg
---

# SVI

网关接口，用于三层交换机跨 Vlan 间路由，具体可以通过 interface vlan 接口配置命令来创建 svi，然后实现路由功能

![svi]({{site.baseurl}}/assets/img/svi-1.png)



## 配置：
 
```
// switch
Switch(config)#ip routing    //开启路由功能
Switch(config)#no ip cef    //关闭cef（这个属于模拟器的bug，真实环境下不用）

// 创建 vlan
Switch(config)# vlan 10，20
// 配置模式
Switch(config-vlan)#int e 0/0
Switch(config-if)#switchport mode access
Switch(config-if)#switchport access vlan 10
Switch(config-if)#no shutdown
Switch(config-vlan)#int e 0/1
Switch(config-if)#switchport mode access
Switch(config-if)#switchport access vlan 20
Switch(config-if)#no shutdown
//创建SVI接口
Switch(config)#interface vlan 10
Switch(config-if)#no sh
Switch(config-if)#ip address 192.168.1.254 255.255.255.0

Switch(config)#interface vlan 20
Switch(config-if)#no sh
Switch(config-if)#ip address 192.168.2.254 255.255.255.0

// PC 
关闭路由功能
PC1(config)#no ip routing
配置 ip
PC1(config)#interface e0/0
PC1(config-if)#no sh
PC1(config-if)#ip address 192.168.1.1 255.255.255.0
PC 配置网关
PC1(config)#ip default-gateway 192.168.1.254
```

由于是三层交换机，192.168.1.0/24 和 192.168.2.0/24 两个网段直接就可以互通了，不需要再去配置路由表，我们可以看一下路由表：

![svi-route]({{site.baseurl}}/assets/img/svi-route.png)

对三层交换机内部的讲解：

由于 e0/0 口是 access 口，所以会被打上 相应 vlan ID=10 的 tag，由于是三层交换机，通过 SVI 模拟路由器，也就是说明进行的是三层通信，可是传送过来的数据包中包含 tag，也就说明存在一个能把 tag 拆掉的 access 口才能通信，所以推测这个口是虚拟的 Vlan 10，同时 Vlan 也是通往新网段的网关

---

# 单臂路由

单臂路由是指在路由器的一个接口上通过配置子接口(并不真实存在的物理接口)的方式，实现原来相互隔离不同的 VLAN 之间的互联互通

![single-arm-routing]({{site.baseurl}}/assets/img/single-arm-routing.png)


## 配置

```
// 交换机
Switch>en
Switch#conf t
Switch(config)#vlan 10,20
Switch(config)#int e  0/0
Switch(config-if)#switchport mode ac
Switch(config-if)#switchport mode access
Switch(config-if)#switchport access vlan 10
Switch(config)#int e  0/1
Switch(config-if)#switchport access vlan 20
Switch(config-if)#no shu
Switch(config-if)#int e 0/2
Switch(config-if)#switchport trunk encapsulation dot1q
Switch(config-if)#switchport mode trunk
Switch(config-if)#no shu

// R1
Router>en
Router#conf t
Router(config)#no ip routing
Router(config)#ho R1
R1(config)#ip default-gateway 192.168.10.254
R1(config)#int e 0/0
R1(config-if)#ip add 192.168.10.1 255.255.255.0
R1(config-if)#no shu
R1(config-if)#do wr

// R2
Router>en
Router#conf t
Router(config)#no ip routing
Router(config)#ho R2
R2(config)#ip default-gateway 192.168.20.254
R2(config)#int e 0/0
R2(config-if)#ip add 192.168.20.1 255.255.255.0
R2(config-if)#no shu
R2(config-if)#do wr


// r4
Router>en
Router#conf t
Router(config)#ho r
r(config)#int e0/0
r(config)#no shu
r(config)#int e0/0.10
r(config-subif)#encapsulation dot1Q 10
r(config-subif)#ip add 192.168.10.254 255.255.255.0
r(config-subif)#no shu
r(config)#int e0/0.20 
r(config-subif)#encapsulation dot1Q 20
r(config-subif)#ip add 192.168.20.254 255.255.255.0
r(config-subif)#no shu
```

---

## 通讯过程

R1 要给 R2发送 ICMP，发现没有对应网关的 MAC 地址，将包搁置。发送 ARP 请求网关的 MAC 地址

Switch 学习后进行泛洪，R4 收到 ARP 请求，并做出 ARP 应答。Switch 再次学习来自 R4 的 Arp 应答，并直接转发给 R1

R1 解封装 ARP 应答包，并且将搁置的 ICMP 包添加 MAC 地址后，发出。

Switch 收到 ICMP 后，之间转发给 R4，R4 解封装发现 三层 IP 是给 自己能到达网段的，进行封包，如下：
4 层：ICMP 报头
3 层：IP 报头，源 IP 192.168.10.1/24 目的 IP 192.168.20.1/24
2 层: 源 MAC：aabb.cc00.4000 目的 MAC：**不清楚**
将包搁置，发送 Arp 请求 获取 R2 的MAC 地址


Switch 学习发来的 Arp 请求，并泛洪。R2 收到 Arp 请求做出应答，Switch 再次学习，然后直接转发给 R1。R1 解析 Arp 应答，并将搁置的 ICMP 包发给 R2。

R2 又会做出 ICMP 应答，Switch 之间转发给 R1，R1 解封装发现 ICMP 的应答报文的目的 IP 是 R1，接着重新封装转发给 Switch。Switch 再直接转发给 R1。

**综上：我们可以发现一个有趣的现象，在 R4 和 交换机的链路上可以看到有双重的 Icmp 的 reqeust 和 reply 如下：**

![total-communication]({{site.baseurl}}/assets/img/total-communication.png)

这里在解释一下两个 request 和 reply 的含义：

第一个 request 是：R1 发送 R4 (R4 是 R1 的网关) 并且应该带有 VLANID = 10 的 Tag，如下

![r1-r4]({{site.baseurl}}/assets/img/r1-r4.png)

第二个 request 是：R4 发给 R2 的 ICMP 包，并且应该带有 VLANID = 20 的 TAG，因为是从虚拟的子接口 Vlan20 发出，如下

![r4-r2]({{site.baseurl}}/assets/img/IMG_0100.png)

第一个 reply 是：R2 发给 R4，带有 VLANID = 20 的 Tag，如下

![r2-r4-reply]({{site.baseurl}}/assets/img/r2-r4.png)

第二个 replay 是：R4 发给 R1 的，带有 VLANID = 10 的 TAG，如下

![r4-r1-reply]({{site.baseurl}}/assets/img/r4-r1.png)

因此我们可以推测出在 R4 内部，进行了 Tag 的去除和封装






 



