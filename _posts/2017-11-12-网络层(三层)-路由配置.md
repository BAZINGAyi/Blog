---
layout: post
tags: [network] # add tag
img: internet.jpg
---

# 路由器

路由器是网络互联的核心设备，它连接不同的网络，在网络之间转发 IP 数据报

---

## 路由表

路由表中记录了从如何达到其他网络的信息。每条路由表主要由三部分组成：目的网络、子网掩码和下一站（路由器的端口 ip，也就是网关）

---

## 静态路由

> 写完立即生效
> 手工配


### 静态路由配置

> 1. 统计网络个数
> 2. 每个路由器需要配置的路由数目等于总的网络数目减去本身连接的网络数目
> 3. 配置静态路由的目的网络直接添加需要去的网络
> 4. 配置静态路由的子网掩码是需要去的网络的子网掩码
> 5. 配置静态路由的下一跳为直接相连的路由器的端口地址

![route_mode]({{site.baseurl}}/assets/img/route_model.png)


```
// R3 预配置命令
enable 
configure terminal
line console 0
no exec-timeout
logging synchronous
no ip domain lookup

// hostname R3
interface ethernet 0/0
ip address 12.1.1.1 255.255.255.0
no shutdown
exit
interface loopback 0
ip address 1.1.1.1 255.255.255.0
no shutdown
exit
// 边界配置默认路由比较省时间
ip route 0.0.0.0 0.0.0.0 12.1.1.2

// hostname R4
interface ethernet 0/0
ip address 12.1.1.2 255.255.255.0
no shutdown
exit
interface loopback 0
ip address 2.2.2.2 255.255.255.0
no shutdown
exit
interface ethernet 0/1
ip address 23.1.1.1 255.255.255.0
no shutdown
exit
// 边界配置默认路由比较省时间
ip route 1.1.1.1 255.255.255.0 12.1.1.1
ip route 3.3.3.3 255.255.255.0 23.1.1.2
```

---

### 静态路由的选择路径选择规则：

mask 匹配最长掩码

最长掩码一样，比较 AD

AD 一样，比较 metric

全都一样负载均摊

---

## 动态路由

### 按寻址算法分类

RIP、BGP

---

### 按链路状态分类

OSPF、IS-IS

---

# SVI

网关接口，用于三层交换机跨 Vlan 间路由，具体可以通过 interface vlan 接口配置命令来创建 svi，然后实现路由功能

![svi]({{site.baseurl}}/assets/img/svi-1.png)



## 配置：
 
```
// switch
Switch(config)#ip routing    //开启路由功能
Switch(config)#no ip cef    //关闭cef（这个属于模拟器的bug，真实环境下不用）

// 创建 vlan
Switch(config)# vlan 10，20
// 配置模式
Switch(config-vlan)#int e 0/0
Switch(config-if)#switchport mode access
Switch(config-if)#switchport access vlan 10
Switch(config-if)#no shutdown
Switch(config-vlan)#int e 0/1
Switch(config-if)#switchport mode access
Switch(config-if)#switchport access vlan 20
Switch(config-if)#no shutdown
//创建SVI接口
Switch(config)#interface vlan 10
Switch(config-if)#no sh
Switch(config-if)#ip address 192.168.1.254 255.255.255.0

Switch(config)#interface vlan 20
Switch(config-if)#no sh
Switch(config-if)#ip address 192.168.2.254 255.255.255.0

// PC 
关闭路由功能
PC1(config)#no ip routing
配置 ip
PC1(config)#interface e0/0
PC1(config-if)#no sh
PC1(config-if)#ip address 192.168.1.1 255.255.255.0
PC 配置网关
PC1(config)#ip default-gateway 192.168.1.254
```

由于是三层交换机，192.168.1.0/24 和 192.168.2.0/24 两个网段直接就可以互通了，不需要再去配置路由表，我们可以看一下路由表：

![svi-route]({{site.baseurl}}/assets/img/svi-route.png)

对三层交换机内部的讲解：

由于 e0/0 口是 access 口，所以会被打上 相应 vlan ID=10 的 tag，由于是三层交换机，通过 SVI 模拟路由器，也就是说明进行的是三层通信，可是传送过来的数据包中包含 tag，也就说明存在一个能把 tag 拆掉的 access 口才能通信，所以推测这个口是虚拟的 Vlan 10，同时 Vlan 也是通往新网段的网关

---

# 单臂路由

单臂路由是指在路由器的一个接口上通过配置子接口(并不真实存在的物理接口)的方式，实现原来相互隔离不同的 VLAN 之间的互联互通

![single-arm-routing]({{site.baseurl}}/assets/img/single-arm-routing.png)


## 配置

```
// 交换机
Switch>en
Switch#conf t
Switch(config)#vlan 10,20
Switch(config)#int e  0/0
Switch(config-if)#switchport mode ac
Switch(config-if)#switchport mode access
Switch(config-if)#switchport access vlan 10
Switch(config)#int e  0/1
Switch(config-if)#switchport access vlan 20
Switch(config-if)#no shu
Switch(config-if)#int e 0/2
Switch(config-if)#switchport trunk encapsulation dot1q
Switch(config-if)#switchport mode trunk
Switch(config-if)#no shu

// R1
Router>en
Router#conf t
Router(config)#no ip routing
Router(config)#ho R1
R1(config)#ip default-gateway 192.168.10.254
R1(config)#int e 0/0
R1(config-if)#ip add 192.168.10.1 255.255.255.0
R1(config-if)#no shu
R1(config-if)#do wr

// R2
Router>en
Router#conf t
Router(config)#no ip routing
Router(config)#ho R2
R2(config)#ip default-gateway 192.168.20.254
R2(config)#int e 0/0
R2(config-if)#ip add 192.168.20.1 255.255.255.0
R2(config-if)#no shu
R2(config-if)#do wr


// r4
Router>en
Router#conf t
Router(config)#ho r
r(config)#int e0/0
r(config)#no shu
r(config)#int e0/0.10
r(config-subif)#encapsulation dot1Q 10
r(config-subif)#ip add 192.168.10.254 255.255.255.0
r(config-subif)#no shu
r(config)#int e0/0.20 
r(config-subif)#encapsulation dot1Q 20
r(config-subif)#ip add 192.168.20.254 255.255.255.0
r(config-subif)#no shu
```

---

## 通讯过程

R1 要给 R2发送 ICMP，发现没有对应网关的 MAC 地址，将包搁置。发送 ARP 请求网关的 MAC 地址

Switch 学习后进行泛洪，R4 收到 ARP 请求，并做出 ARP 应答。Switch 再次学习来自 R4 的 Arp 应答，并直接转发给 R1

R1 解封装 ARP 应答包，并且将搁置的 ICMP 包添加 MAC 地址后，发出。

Switch 收到 ICMP 后，之间转发给 R4，R4 解封装发现 三层 IP 是给 自己能到达网段的，进行封包，如下：
4 层：ICMP 报头
3 层：IP 报头，源 IP 192.168.10.1/24 目的 IP 192.168.20.1/24
2 层: 源 MAC：aabb.cc00.4000 目的 MAC：**不清楚**
将包搁置，发送 Arp 请求 获取 R2 的MAC 地址


Switch 学习发来的 Arp 请求，并泛洪。R2 收到 Arp 请求做出应答，Switch 再次学习，然后直接转发给 R1。R1 解析 Arp 应答，并将搁置的 ICMP 包发给 R2。

R2 又会做出 ICMP 应答，Switch 之间转发给 R1，R1 解封装发现 ICMP 的应答报文的目的 IP 是 R1，接着重新封装转发给 Switch。Switch 再直接转发给 R1。

**综上：我们可以发现一个有趣的现象，在 R4 和 交换机的链路上可以看到有双重的 Icmp 的 reqeust 和 reply 如下：**

![total-communication]({{site.baseurl}}/assets/img/total-communication.png)

这里在解释一下两个 request 和 reply 的含义：

第一个 request 是：R1 发送 R4 (R4 是 R1 的网关) 并且应该带有 VLANID = 10 的 Tag，如下

![r1-r4]({{site.baseurl}}/assets/img/r1-r4.png)

第二个 request 是：R4 发给 R2 的 ICMP 包，并且应该带有 VLANID = 20 的 TAG，因为是从虚拟的子接口 Vlan20 发出，如下

![r4-r2]({{site.baseurl}}/assets/img/IMG_0100.png)

第一个 reply 是：R2 发给 R4，带有 VLANID = 20 的 Tag，如下

![r2-r4-reply]({{site.baseurl}}/assets/img/r2-r4.png)

第二个 replay 是：R4 发给 R1 的，带有 VLANID = 10 的 TAG，如下

![r4-r1-reply]({{site.baseurl}}/assets/img/r4-r1.png)

因此我们可以推测出在 R4 内部，进行了 Tag 的去除和封装






 



